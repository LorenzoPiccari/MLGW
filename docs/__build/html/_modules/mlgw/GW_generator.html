

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>mlgw.GW_generator &#8212; mlgw 3.0.0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/mlgw/GW_generator';</script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    <p class="title logo__title">mlgw 3.0.0 documentation</p>
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Usage</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../usage/install.html">Installing <code class="docutils literal notranslate"><span class="pre">mlgw</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage/overview.html">What <code class="docutils literal notranslate"><span class="pre">mlgw</span></code> can do for you</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">API reference</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../api_reference/GW_generator.html">Module GW_generator.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_reference/NN_model.html">Module NN_model.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_reference/EM_MoE.html">Module EM_MoE.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_reference/ML_routines.html">Module ML_routines.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_reference/GW_helper.html">Module GW_helper.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_reference/fit_model.html">Module fit_model.py</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">About</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <h1>Source code for mlgw.GW_generator</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module GW_generator.py</span>
<span class="sd">======================</span>

<span class="sd">Definition of class MLGW_generator and mode_generator.</span>

<span class="sd">- :class:`GW_generator` bounds together many mode_generator and builds the complete WF as a sum of different modes.	</span>

<span class="sd">- :class:`mode_generator_NN` and :class:`mode_generator_MoE`: generate a specific l,m mode of GW signal of a BBH coalescence when given orbital parameters of the BBH. They uses different regression models</span>

<span class="sd">The model performs the regression:</span>

<span class="sd">	theta = (q,s1,s2) ---&gt; g ---&gt; A, ph = W g</span>

<span class="sd">The first regression is done by a MoE model or by a neural network; the second regression is a PCA model. Some optional parameters can be given to specify the observer position.</span>
<span class="sd">It makes use of modules EM_MoE.py and ML_routines.py for an implementation of a PCA model and a MoE fitted by EM algorithm.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">#################</span>

<span class="c1">#TODO: implement Wigner matrix as in https://dcc.ligo.org/LIGO-T2000446 eqs. (2.4) and (2.8): more straightforward expression!</span>
<span class="c1">#FIXME: make the MoE model compatible also with 1D vectors (i.e. one single expert)</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">ast</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">from</span> <span class="nn">tensorflow.keras</span> <span class="kn">import</span> <span class="n">models</span> <span class="k">as</span> <span class="n">keras_models</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span> 	<span class="c1">#adding to path folder where mlgw package is installed (ugly?)</span>
<span class="kn">from</span> <span class="nn">.EM_MoE</span> <span class="kn">import</span> <span class="n">MoE_model</span> <span class="c1">#WARNING commented out </span>
<span class="kn">from</span> <span class="nn">.ML_routines</span> <span class="kn">import</span> <span class="n">PCA_model</span><span class="p">,</span> <span class="n">add_extra_features</span><span class="p">,</span> <span class="n">jac_extra_features</span><span class="p">,</span> <span class="n">augment_features_general</span>
<span class="kn">from</span> <span class="nn">.NN_model</span> <span class="kn">import</span> <span class="n">load_models_from_directories</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">factorial</span> <span class="k">as</span> <span class="n">fact</span>



<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span> <span class="c1">#DEBUG</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;always&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span> <span class="c1">#always print a UserWarning message ??</span>

<span class="c1">#############DEBUG PROFILING</span>
<span class="k">try</span><span class="p">:</span>
	<span class="kn">from</span> <span class="nn">line_profiler</span> <span class="kn">import</span> <span class="n">LineProfiler</span>

	<span class="k">def</span> <span class="nf">do_profile</span><span class="p">(</span><span class="n">follow</span><span class="o">=</span><span class="p">[]):</span>
		<span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
			<span class="k">def</span> <span class="nf">profiled_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
				<span class="k">try</span><span class="p">:</span>
					<span class="n">profiler</span> <span class="o">=</span> <span class="n">LineProfiler</span><span class="p">()</span>
					<span class="n">profiler</span><span class="o">.</span><span class="n">add_function</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
					<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">follow</span><span class="p">:</span>
						<span class="n">profiler</span><span class="o">.</span><span class="n">add_function</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
					<span class="n">profiler</span><span class="o">.</span><span class="n">enable_by_count</span><span class="p">()</span>
					<span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
				<span class="k">finally</span><span class="p">:</span>
					<span class="n">profiler</span><span class="o">.</span><span class="n">print_stats</span><span class="p">()</span>
			<span class="k">return</span> <span class="n">profiled_func</span>
		<span class="k">return</span> <span class="n">inner</span>
<span class="k">except</span><span class="p">:</span>
	<span class="k">pass</span>

<span class="c1">################# GW_generator class</span>
<div class="viewcode-block" id="list_models"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.list_models">[docs]</a><span class="k">def</span> <span class="nf">list_models</span><span class="p">(</span><span class="n">print_out</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Print to screen the models available by default in the relevant folder.</span>

<span class="sd">	Input:</span>
<span class="sd">		print_out: bool</span>
<span class="sd">			Whether the output should be printed (if False, it is returned as a string)</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">print_out</span><span class="p">:</span>
		<span class="n">to_return</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">to_return</span> <span class="o">=</span> <span class="kc">None</span>
	<span class="n">models</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">getfile</span><span class="p">(</span><span class="n">list_models</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;/TD_models&quot;</span><span class="p">)</span>
	<span class="n">models</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
	<span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">models</span><span class="p">:</span>
		<span class="n">folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">getfile</span><span class="p">(</span><span class="n">list_models</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;/TD_models/&quot;</span><span class="o">+</span><span class="n">model</span>
		<span class="n">files</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span>
		<span class="k">if</span> <span class="s2">&quot;README&quot;</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
			<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">folder</span><span class="o">+</span><span class="s2">&quot;/README&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
				<span class="n">contents</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
			<span class="n">temp_dict</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span> <span class="c1">#dictionary holding some relevant information about the model loaded</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="n">temp_dict</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span> <span class="c1">#dictionary holding some relevant information about the model loaded</span>
				<span class="n">description</span> <span class="o">=</span> <span class="n">temp_dict</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span>
				<span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;: &quot;</span><span class="o">+</span> <span class="n">description</span>
			<span class="k">except</span><span class="p">:</span>
				<span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
		<span class="n">model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">print_out</span><span class="p">:</span>
			<span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="o">+</span><span class="n">description</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">to_return</span> <span class="o">+=</span> <span class="n">model</span><span class="o">+</span><span class="n">description</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

	<span class="k">return</span> <span class="n">to_return</span></div>


<div class="viewcode-block" id="GW_generator"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.GW_generator">[docs]</a><span class="k">class</span> <span class="nc">GW_generator</span><span class="p">:</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	This class holds a collection of mode_generator istances and provides the code to generate a full GW signal with the higher modes, with the ML model.</span>
<span class="sd">	It builds the WF as:</span>
<span class="sd">	</span>
<span class="sd">	.. math::</span>

<span class="sd">		h = h_+ + i h_\\times = \sum_{\ell m} Y_{\ell m} H_{\ell m}(t)</span>

<span class="sd">	The model shall be saved in a single folder, which collects a different subfolder &quot;lm&quot; for each mode to generate. Each mode is independent from the others and modes can be added at will.</span>
<span class="sd">	Some default models are already included in the package.</span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">folder</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">isNN</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Initialise class by loading the modes from file.</span>
<span class="sd">		A number of pre-fitted models for the modes are released: they can be loaded with folder argument by specifying an integer index (default 0. They are all saved in &quot;__dir__/TD_models/model_(index_given)&quot;. A list of the available models can be listed with list models().</span>
<span class="sd">		Each model is composed by many modes. Each mode is represented by a mode_generator istance, each saved in a different folder within the folder.</span>
<span class="sd">		</span>
<span class="sd">		Inputs:</span>
<span class="sd">			folder: str</span>
<span class="sd">				Folder in which everything is kept (if None, models must be loaded manually with load())</span>
<span class="sd">			verbose: str</span>
<span class="sd">				Whether to be verbose when loading the model</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">modes</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#list of modes (classes mode_generator)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">mode_dict</span> <span class="o">=</span> <span class="p">{}</span>

		<span class="k">if</span> <span class="n">folder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
				<span class="n">int_folder</span> <span class="o">=</span> <span class="n">folder</span>
				<span class="n">folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">getfile</span><span class="p">(</span><span class="n">GW_generator</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;/TD_models/model_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span>
				<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">folder</span><span class="p">):</span>
					<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Given value </span><span class="si">{0}</span><span class="s2"> for pre-fitted model is not valid. Available models are:</span><span class="se">\n</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">int_folder</span><span class="p">),</span> <span class="n">list_models</span><span class="p">(</span><span class="kc">False</span><span class="p">)))</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">isNN</span> <span class="o">=</span> <span class="n">isNN</span><span class="p">)</span>
		<span class="k">return</span>

	<span class="k">def</span> <span class="nf">__extract_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">folder</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Given a folder name, it extract (if present) the tuple of the mode the folder contains.</span>
<span class="sd">		Each mode folder must start with &quot;lm&quot;.</span>

<span class="sd">		Input:</span>
<span class="sd">			folder: str</span>
<span class="sd">				folder holding a mode</span>
<span class="sd">		Output:</span>
<span class="sd">			mode: tuple</span>
<span class="sd">				(l,m) tuple for the mode (None if no mode is found in name)</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	
		<span class="n">m</span> <span class="o">=</span> <span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="n">lm</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
			<span class="k">assert</span> <span class="n">l</span><span class="o">&gt;=</span><span class="n">m</span>
		<span class="k">except</span><span class="p">:</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Folder </span><span class="si">{}</span><span class="s1">: name not recognized as a valid mode - skipping its content&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
			<span class="k">return</span> <span class="kc">None</span>
		<span class="k">return</span> <span class="n">lm</span>

<div class="viewcode-block" id="GW_generator.load"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.GW_generator.load">[docs]</a>	<span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">folder</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">isNN</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Loads the GW generator by loading the different mode_generator classes.</span>
<span class="sd">		Each mode is loaded from a dedicated folder in the given folder of the model.</span>
<span class="sd">		An optional README files holds some information about the model.</span>
<span class="sd">		</span>
<span class="sd">		Inputs:</span>
<span class="sd">			folder: str</span>
<span class="sd">				Folder in which everything is kept</span>
<span class="sd">			verbose: bool</span>
<span class="sd">				Whether to be verbose</span>
<span class="sd">			isNN: bool</span>
<span class="sd">				Whether the regression model is neural network, as opposed to a MoE</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">folder</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unable to load folder &quot;</span><span class="o">+</span><span class="n">folder</span><span class="o">+</span><span class="s2">&quot;: no such directory!&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="n">folder</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">):</span>
			<span class="n">folder</span> <span class="o">=</span> <span class="n">folder</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span>
		<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loading model from: &quot;</span><span class="p">,</span> <span class="n">folder</span><span class="p">)</span>
		<span class="n">file_list</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span>
		
		<span class="k">if</span> <span class="s1">&#39;README&#39;</span> <span class="ow">in</span> <span class="n">file_list</span><span class="p">:</span>
			<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">folder</span><span class="o">+</span><span class="s2">&quot;README&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
				<span class="n">contents</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">readme</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span> <span class="c1">#dictionary holding some relevant information about the model loaded</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">readme</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span> <span class="c1">#dictionary holding some relevant information about the model loaded</span>
				<span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">readme</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span>
			<span class="k">except</span><span class="p">:</span>
				<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;README file is not a valid dictionary: entry ignored&quot;</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">readme</span> <span class="o">=</span> <span class="kc">None</span>
			<span class="n">file_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;README&#39;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">readme</span> <span class="o">=</span> <span class="kc">None</span>

		<span class="c1">#loading modes</span>
		<span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">file_list</span><span class="p">:</span>
			<span class="n">lm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__extract_mode</span><span class="p">(</span><span class="n">folder</span><span class="o">+</span><span class="n">mode</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">lm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
				<span class="k">continue</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">mode_dict</span><span class="p">[</span><span class="n">lm</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="p">)</span>

					<span class="c1">#Checking for the type of mode generator (FIXME: make this better! How to know which generator to use?)</span>
				<span class="k">if</span> <span class="n">isNN</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mode_generator_NN</span><span class="p">(</span><span class="n">lm</span><span class="p">,</span> <span class="n">folder</span><span class="o">+</span><span class="n">mode</span><span class="p">))</span> <span class="c1">#loads mode_generator</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mode_generator_MoE</span><span class="p">(</span><span class="n">lm</span><span class="p">,</span> <span class="n">folder</span><span class="o">+</span><span class="n">mode</span><span class="p">))</span> <span class="c1">#loads mode_generator</span>

			<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    Loaded mode </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lm</span><span class="p">))</span>

		<span class="k">return</span></div>

<div class="viewcode-block" id="GW_generator.get_precessing_params"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.GW_generator.get_precessing_params">[docs]</a>	<span class="k">def</span> <span class="nf">get_precessing_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Given the two masses and (dimensionless) spins, it computes the angles between the two spins and the orbital angular momentum (theta1, theta2) and the angle between the projections of the two spins onto the orbital plane (delta_Phi). Please, refer to eqs. (1-4) of https://arxiv.org/abs/1605.01067.</span>
<span class="sd">		Spins must be in the L frame, in which the orbital angular momentum has only the z compoment; they are evaluated when at a given orbital frequency f = 20 Hz (????????????????????????? check better here)</span>
<span class="sd">		Returns the six variables (i.e. q, chi1, chi2, theta1, theta2, delta_Phi) useful for reconstructing precession angles alpha and beta with the NN.</span>
<span class="sd">		Assumes that always (m1&gt;m2)</span>
<span class="sd">		</span>
<span class="sd">		Inputs:</span>
<span class="sd">			m1: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape ()/(N,) - mass of BH 1</span>
<span class="sd">			m2: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape ()/(N,) - mass of BH 2</span>
<span class="sd">			s1: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (3,)/(N,3) - (dimensionless) spin components of BH 1			</span>
<span class="sd">			s2: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape: (3,)/(N,3) - (dimensionless) spin components of BH 2</span>
<span class="sd">		</span>
<span class="sd">		Ouput:</span>
<span class="sd">			q: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape ()/(N,) - mass ratio (&gt;1)</span>
<span class="sd">			chi1: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				()/(N,) - dimensionless spin 1 magnitude</span>
<span class="sd">			chi2: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				()/(N,)	- dimensionless spin 1 magnitude</span>
<span class="sd">			theta1: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape ()/(N,) - angle between spin 1 and the orbital angular momentum</span>
<span class="sd">			theta2: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape ()/(N,) - angle between spin 2 and the orbital angular momentum</span>
<span class="sd">			delta_Phi: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape ()/(N,) -angle between the projections of the two spins onto the orbital plane</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">s1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">s1</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span>
			<span class="n">s2</span> <span class="o">=</span> <span class="n">s2</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span><span class="mi">3</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Spin vectors must have 3 components! Instead they have </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2"> components&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
		
		<span class="n">chi1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">#(N,)</span>
		<span class="n">chi2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">#(N,)</span>
		<span class="n">theta1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">s1</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">chi1</span><span class="p">)</span> <span class="c1">#(N,)</span>
		<span class="n">theta2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">s2</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">chi2</span><span class="p">)</span> <span class="c1">#(N,)</span>
		<span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">])</span>
				
		<span class="n">plane_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">s1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">s1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">s1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)])</span> <span class="c1">#(N,3) #s1xL</span>
		<span class="n">plane_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">s2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">s2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">s2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)])</span>
		<span class="n">sign</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">plane_1</span><span class="p">,</span><span class="n">plane_2</span><span class="p">)[:,</span><span class="mi">2</span><span class="p">])</span> <span class="c1">#(N,) #computing the sign</span>
		
		<span class="n">plane_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">plane_1</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">plane_1</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mf">1e-30</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="c1">#(N,3)</span>
		<span class="n">plane_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">plane_2</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">plane_2</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mf">1e-30</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="c1">#(N,3)</span>
		<span class="n">delta_Phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">plane_1</span><span class="p">,</span><span class="n">plane_2</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span><span class="mi">1</span><span class="p">))</span> <span class="c1">#(N,)</span>

		<span class="n">delta_Phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">delta_Phi</span><span class="p">,</span> <span class="n">sign</span><span class="p">)</span> <span class="c1">#(N,) #setting the right sign</span>
		
		<span class="k">return</span> <span class="n">m1</span><span class="o">/</span><span class="n">m2</span><span class="p">,</span> <span class="n">chi1</span><span class="p">,</span> <span class="n">chi2</span><span class="p">,</span> <span class="n">theta1</span><span class="p">,</span> <span class="n">theta2</span><span class="p">,</span> <span class="n">delta_Phi</span></div>
		
<div class="viewcode-block" id="GW_generator.summary"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.GW_generator.summary">[docs]</a>	<span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Prints to screen a summary of the model currently used.</span>
<span class="sd">		If filename is given, output is also redirected to file.</span>

<span class="sd">		Input:</span>
<span class="sd">			filename: str</span>
<span class="sd">				if not `None`, redirects the output to file</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">output</span> <span class="o">=</span> <span class="s2">&quot;###### Summary for MLGW model ######</span><span class="se">\n</span><span class="s2">&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">readme</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">readme</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
			<span class="k">if</span> <span class="s2">&quot;description&quot;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
				<span class="n">output</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readme</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
				<span class="n">keys</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;description&#39;</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
				<span class="n">output</span> <span class="o">+=</span> <span class="s2">&quot;   &quot;</span><span class="o">+</span><span class="n">k</span><span class="o">+</span><span class="s2">&quot;: &quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">readme</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
			<span class="n">text_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span>
			<span class="n">text_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
			<span class="n">text_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
			<span class="k">return</span>
		<span class="k">elif</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Filename must be a string! &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot; given. Output is redirected to standard output.&quot;</span> <span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
		<span class="k">return</span></div>

<div class="viewcode-block" id="GW_generator.list_modes"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.GW_generator.list_modes">[docs]</a>	<span class="k">def</span> <span class="nf">list_modes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">print_screen</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns a list of the available modes.</span>
<span class="sd">		If print_screen is True, it also prints to screen</span>

<span class="sd">		Output:</span>
<span class="sd">			mode_list: list</span>
<span class="sd">				List with the available modes</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">mode_list</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="p">:</span>
			<span class="n">mode_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mode</span><span class="o">.</span><span class="n">lm</span><span class="p">())</span>
		<span class="k">if</span> <span class="n">print_screen</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">mode_list</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">mode_list</span></div>


	<span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t_grid</span><span class="p">,</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">spin1_x</span><span class="p">,</span> <span class="n">spin1_y</span><span class="p">,</span> <span class="n">spin1_z</span><span class="p">,</span> <span class="n">spin2_x</span><span class="p">,</span> <span class="n">spin2_y</span><span class="p">,</span> <span class="n">spin2_z</span><span class="p">,</span> <span class="n">D_L</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">phi_0</span><span class="p">,</span> <span class="n">long_asc_nodes</span><span class="p">,</span> <span class="n">eccentricity</span><span class="p">,</span> <span class="n">mean_per_ano</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Generates a WF according to the model. It makes all the required preprocessing to include wave dependance on the full 14 parameters space of the GW forms. It outputs the plus cross polarization of the WF.</span>
<span class="sd">		All the available modes are employed to build the WF.</span>
<span class="sd">		The WF is shifted such that the peak of the 22 mode is placed at t=0. If the reference phase is 0, the phase of the 22 mode is 0 at the beginning of the time grid.</span>
<span class="sd">		Note that the dependence on the longitudinal ascension node, the eccentricity, the mean periastron anomaly and the orthogonal spin components is not currently implemented and it is mainted for compatibility with lal.</span>
<span class="sd">		</span>
<span class="sd">		Input:</span>
<span class="sd">			t_grid: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (D,) - Grid of (physical) time points to evaluate the wave at</span>
<span class="sd">			m1: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape ()/(N,) - Mass of BH 1</span>
<span class="sd">			m2: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape ()/(N,) - Mass of BH 2</span>
<span class="sd">			spin1_x/y/z: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape ()/(N,) - Each variable represents a spin component of BH 1</span>
<span class="sd">			spin2_x/y/z: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape ()/(N,) - Each variable represents a spin component of BH 2</span>
<span class="sd">			D_L: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape ()/(N,) - Luminosity distance</span>
<span class="sd">			i: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape ()/(N,) - Inclination</span>
<span class="sd">			phi_0: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape ()/(N,) - Reference phase for the wave</span>
<span class="sd">			long_asc_nodes: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape ()/(N,) - Logitudinal ascentional nodes (currently not implemented)</span>
<span class="sd">			eccentricity: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape ()/(N,) - Eccentricity of the orbit (currently not implemented)</span>
<span class="sd">			mean_per_ano: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape ()/(N,) - Mean periastron anomaly (currently not implemented)</span>
<span class="sd">		</span>
<span class="sd">		Output:</span>
<span class="sd">			h_plus, h_cross: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (1,D)/(N,D) - desidered polarizations</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">spin1_x</span><span class="p">,</span> <span class="n">spin1_y</span><span class="p">,</span> <span class="n">spin1_z</span><span class="p">,</span> <span class="n">spin2_x</span><span class="p">,</span> <span class="n">spin2_y</span><span class="p">,</span> <span class="n">spin2_z</span><span class="p">,</span> <span class="n">D_L</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">phi_0</span><span class="p">,</span> <span class="n">long_asc_nodes</span><span class="p">,</span> <span class="n">eccentricity</span><span class="p">,</span> <span class="n">mean_per_ano</span><span class="p">))</span> <span class="c1">#(N,D)</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_WF</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">t_grid</span><span class="o">=</span> <span class="n">t_grid</span><span class="p">,</span> <span class="n">modes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

	<span class="c1">#@do_profile(follow=[])</span>
<div class="viewcode-block" id="GW_generator.get_WF"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.GW_generator.get_WF">[docs]</a>	<span class="k">def</span> <span class="nf">get_WF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">t_grid</span><span class="p">,</span> <span class="n">modes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Generates a WF according to the model. It makes all the required preprocessing to include wave dependance on the full 14 parameters space of the GW forms. It outputs the plus cross polarization of the WF.</span>
<span class="sd">		All the available modes are employed to build the WF.</span>
<span class="sd">		The WF is shifted such that the peak of the 22 mode is placed at t=0. If the reference phase is 0, the phase of the 22 mode is 0 at the beginning of the time grid.</span>
<span class="sd">		If no geometrical variables are given, it is set by default D_L = 1 Mpc, iota = phi_0 = 0.</span>
<span class="sd">		It accepts data in one of the following layout of D features:</span>
<span class="sd">			</span>
<span class="sd">			D = 3	[q, spin1_z, spin2_z]</span>
<span class="sd">			</span>
<span class="sd">			D = 4	[m1, m2, spin1_z, spin2_z]</span>
<span class="sd">			</span>
<span class="sd">			D = 5	[m1, m2, spin1_z , spin2_z, D_L]</span>
<span class="sd">			</span>
<span class="sd">			D = 6	[m1, m2, spin1_z , spin2_z, D_L, inclination]</span>
<span class="sd">			</span>
<span class="sd">			D = 7	[m1, m2, spin1_z , spin2_z, D_L, inclination, phi_0]</span>
<span class="sd">			</span>
<span class="sd">			D = 14	[m1, m2, spin1 (3,), spin2 (3,), D_L, inclination, phi_0, long_asc_nodes, eccentricity, mean_per_ano]</span>
<span class="sd">			</span>
<span class="sd">		In the D = 3 layout, the total mass is set to 20 M_sun by default.</span>
<span class="sd">		Warning: last layout (D=14) is made only for compatibility with lalsuite software. The implemented variables are those in D=7 layout; the other are dummy variables and will not be considered.</span>
<span class="sd">		Unit of measures:</span>
<span class="sd">		</span>
<span class="sd">			[mass] = M_sun</span>
<span class="sd">		</span>
<span class="sd">			[D_L] = Mpc</span>
<span class="sd">		</span>
<span class="sd">			[spin] = adimensional</span>
<span class="sd">		</span>
<span class="sd">		User might choose which modes are to be included in the WF.</span>

<span class="sd">		Input:</span>
<span class="sd">			theta: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (D,)/(N,D) - source parameters to make prediction at</span>
<span class="sd">			t_grid: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (D&#39;,) - a grid in (reduced) time to evaluate the wave at (uses np.interp)</span>
<span class="sd">			modes: list</span>
<span class="sd">				list of modes employed for building the WF (if None, every mode available is employed)</span>

<span class="sd">		Ouput:</span>
<span class="sd">			h_plus, h_cross (D,)/(N,D)		desidered polarizations (if it applies)</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">modes</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="n">modes</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
			<span class="n">modes</span> <span class="o">=</span> <span class="p">[</span><span class="n">modes</span><span class="p">]</span>
		<span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="c1">#to ensure user theta is copied into new array</span>
		<span class="k">if</span> <span class="n">theta</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">to_reshape</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1">#whether return a one dimensional array</span>
			<span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span> <span class="c1">#(1,D)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">to_reshape</span> <span class="o">=</span> <span class="kc">False</span>
		
		<span class="n">D</span><span class="o">=</span> <span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#number of features given</span>
		<span class="k">if</span> <span class="n">D</span> <span class="o">&lt;</span><span class="mi">3</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unable to generata WF. Too few parameters given!!&quot;</span><span class="p">)</span>
			<span class="k">return</span>

			<span class="c1">#creating a standard theta vector for __get_WF</span>
		<span class="k">if</span> <span class="n">D</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
			<span class="n">new_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">7</span><span class="p">))</span>
			<span class="n">new_theta</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
			<span class="n">new_theta</span><span class="p">[:,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[:,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span> <span class="c1">#setting spins</span>
			<span class="n">new_theta</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mf">20.</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">20.</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])]</span> <span class="c1">#setting m1,m2 with M = 20</span>
			<span class="n">theta</span> <span class="o">=</span> <span class="n">new_theta</span> <span class="c1">#(N,7)</span>

		<span class="k">if</span> <span class="n">D</span><span class="o">&gt;</span><span class="mi">3</span> <span class="ow">and</span> <span class="n">D</span><span class="o">!=</span><span class="mi">7</span><span class="p">:</span>
			<span class="n">new_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">7</span><span class="p">))</span>
			<span class="n">new_theta</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
			<span class="k">if</span> <span class="n">D</span><span class="o">==</span> <span class="mi">14</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span> <span class="n">theta</span><span class="p">[:,</span><span class="mi">5</span><span class="p">:</span><span class="mi">7</span><span class="p">]))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
					<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Given nonzero spin_x/spin_y components. Model currently supports only spin_z component. Other spin components are ignored&quot;</span><span class="p">)</span>
				<span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
				<span class="n">indices_new_theta</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">D</span><span class="p">)]</span>
				<span class="n">indices_new_theta</span> <span class="o">=</span> <span class="n">indices</span>


				<span class="c1">#building vector to keep standard layout for __get_WF</span>
			<span class="n">new_theta</span><span class="p">[:,</span> <span class="n">indices_new_theta</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[:,</span><span class="n">indices</span><span class="p">]</span>
			<span class="n">theta</span> <span class="o">=</span> <span class="n">new_theta</span> <span class="c1">#(N,7)</span>

		<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">theta</span><span class="p">[:,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">,</span><span class="n">theta</span><span class="p">[:,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span><span class="o">&lt;=-</span><span class="mi">1</span><span class="p">)):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong value for spins, please set a value in range [-1,1]&quot;</span><span class="p">)</span>

			<span class="c1">#generating waves and returning to user</span>
		<span class="n">h_plus</span><span class="p">,</span> <span class="n">h_cross</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_WF</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">t_grid</span><span class="p">,</span> <span class="n">modes</span><span class="p">)</span> <span class="c1">#(N,D)</span>
		<span class="k">if</span> <span class="n">to_reshape</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">h_plus</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">h_cross</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="c1">#(D,)</span>
		<span class="k">return</span> <span class="n">h_plus</span><span class="p">,</span> <span class="n">h_cross</span> <span class="c1">#(N,D)</span></div>

	<span class="k">def</span> <span class="nf">__check_modes_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">modes</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Checks that all the inputs of get_modes and get_twisted_modes are fine and makes them ready for processing. It also states whether the output shall be squeezes over some axis.</span>

<span class="sd">		Input:</span>
<span class="sd">			theta: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,D)/(D,) - source parameters to compute the modes at</span>
<span class="sd">			modes: list</span>
<span class="sd">				list (or tuple) of modes to consider</span>

<span class="sd">		Output:</span>

<span class="sd">			theta: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,D)/(D,) - as in input but perhaps reshaped</span>
<span class="sd">			modes: list</span>
<span class="sd">				list of modes (even if input was a tuple)</span>
<span class="sd">			remove_first_dim: bool</span>
<span class="sd">				whether to remove the first axis on the ouput</span>
<span class="sd">			remove_last_dim: bool</span>
<span class="sd">				whether to remove the last axis on the ouput</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">modes</span><span class="p">,</span><span class="nb">tuple</span><span class="p">):</span> <span class="c1">#it means that the last dimension should be deleted</span>
			<span class="n">modes</span> <span class="o">=</span> <span class="p">[</span><span class="n">modes</span><span class="p">]</span>
			<span class="n">remove_last_dim</span> <span class="o">=</span> <span class="kc">True</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">remove_last_dim</span> <span class="o">=</span> <span class="kc">False</span>

		<span class="k">if</span> <span class="n">modes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">modes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_modes</span><span class="p">()</span>

		<span class="k">if</span> <span class="n">theta</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span>
			<span class="n">remove_first_dim</span> <span class="o">=</span> <span class="kc">True</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">remove_first_dim</span> <span class="o">=</span> <span class="kc">False</span>
		
		<span class="k">if</span> <span class="n">theta</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Wrong number of input theta dimensions: 2 expected but </span><span class="si">{}</span><span class="s2"> given&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

		<span class="k">return</span> <span class="n">theta</span><span class="p">,</span> <span class="n">modes</span><span class="p">,</span> <span class="n">remove_first_dim</span><span class="p">,</span> <span class="n">remove_last_dim</span>

<div class="viewcode-block" id="GW_generator.get_merger_frequency"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.GW_generator.get_merger_frequency">[docs]</a>	<span class="k">def</span> <span class="nf">get_merger_frequency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns the (approximate) merger frequency in Hz, computed as half the 22 mode frequency at the peak of amplitude.</span>
<span class="sd">		</span>
<span class="sd">		Input:</span>
<span class="sd">			theta: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,4)/(4,) - Values of the intrinsic parameters</span>
<span class="sd">		</span>
<span class="sd">		Output:</span>
<span class="sd">			f_merger: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape ()/(N,) - Merger frequency in Hz</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">theta</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span>
		<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.001</span>
		<span class="n">t_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">dt</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">amp</span><span class="p">,</span> <span class="n">ph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_modes</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">t_grid</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">out_type</span> <span class="o">=</span> <span class="s2">&quot;ampph&quot;</span><span class="p">)</span><span class="c1">#(N,2)</span>
		<span class="n">f_merger</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span> <span class="p">(</span><span class="n">ph</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ph</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span> <span class="c1">#(N,)</span>
		<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f_merger</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span></div>
	
<div class="viewcode-block" id="GW_generator.get_orbital_frequency"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.GW_generator.get_orbital_frequency">[docs]</a>	<span class="k">def</span> <span class="nf">get_orbital_frequency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns the (approximate) orbital frequency in Hz, computed as half the 22 mode frequency at a given time t.</span>
<span class="sd">		</span>
<span class="sd">		Input:</span>
<span class="sd">			theta: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,4)/(4,) - Values of the intrinsic parameters</span>
<span class="sd">			t: float</span>
<span class="sd">				Time at which the orbital frequency shall be evaluated (the 0 is the time of the merger)		</span>

<span class="sd">		Output:</span>
<span class="sd">			f_merger: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape ()/(N,) - Merger frequency in Hz</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">theta</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span>
		<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.001</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
		<span class="n">t_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">t</span><span class="o">-</span><span class="n">dt</span><span class="p">,</span> <span class="o">-</span><span class="n">t</span> <span class="o">+</span> <span class="n">dt</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>
		<span class="n">amp</span><span class="p">,</span> <span class="n">ph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_modes</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">t_grid</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">out_type</span> <span class="o">=</span> <span class="s2">&quot;ampph&quot;</span><span class="p">)</span><span class="c1">#(N,2)</span>
		<span class="n">f_t</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span> <span class="p">(</span><span class="n">ph</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ph</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span> <span class="c1">#(N,)</span>
		<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f_t</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span></div>

<div class="viewcode-block" id="GW_generator.get_merger_time"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.GW_generator.get_merger_time">[docs]</a>	<span class="k">def</span> <span class="nf">get_merger_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Given an orbital frequency, it computes the merger time for a given set of BBH parameters</span>

<span class="sd">		Input:</span>
<span class="sd">			f: float</span>
<span class="sd">				starting frequency of the WF</span>
<span class="sd">			theta: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,4)/(4,) - source parameters (m1, m2, s1z, s2z)</span>

<span class="sd">		Output:</span>
<span class="sd">			tau: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,1)/(1,) - time to merger</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">theta</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span>
		<span class="n">t_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
		<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
		<span class="n">_</span><span class="p">,</span> <span class="n">ph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_modes</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">t_grid</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">out_type</span> <span class="o">=</span> <span class="s2">&quot;ampph&quot;</span><span class="p">)</span><span class="c1">#(N,D)</span>
		<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;default&#39;</span><span class="p">)</span>
			<span class="c1">#computing frequency as a function of time</span>
		<span class="n">f_t</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">ph</span><span class="p">,</span> <span class="n">t_grid</span> <span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">#(N,D)</span>
		
		<span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))</span>
		
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
			<span class="n">tau</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">([</span><span class="n">f</span><span class="p">],</span> <span class="n">f_t</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">t_grid</span><span class="p">)</span>
		
		<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span></div>

<div class="viewcode-block" id="GW_generator.get_NP_theta"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.GW_generator.get_NP_theta">[docs]</a>	<span class="k">def</span> <span class="nf">get_NP_theta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Given a parameter vector theta with 6 dimensional spin parameter (second dim = 8), it computes the low dimensional spin version, suitable for generating the WF with spin twist.</span>

<span class="sd">		Input:</span>
<span class="sd">			theta: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,8)/(8,) - source parameters to make prediction at (m1, m2, s1 (3,), s2 (3,))</span>

<span class="sd">		Output:</span>
<span class="sd">			theta: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,8)/(8,) - The same orbital parameters with precession removed</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">to_reshape</span> <span class="o">=</span> <span class="kc">False</span>
		<span class="k">if</span> <span class="n">theta</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span>
			<span class="n">to_reshape</span> <span class="o">=</span> <span class="kc">False</span>
		
		<span class="n">theta_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">theta</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">],</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">5</span><span class="p">:</span><span class="mi">8</span><span class="p">],</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]]</span> <span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">#(N,4) #theta for generating the non-precessing WFs</span>
		<span class="c1">#theta_new[:,[2,3]] = np.multiply(theta_new[:,[2,3]], np.sign(theta[:,[4,7]]))</span>
			 <span class="c1"># (sx, sy, sz) -&gt; (0,0, s * sign(sz) )</span>
		<span class="n">theta_new</span><span class="p">[:,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[:,[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">]]</span> <span class="c1"># (sx, sy, sz) -&gt; (0,0,sz)</span>
		
		<span class="k">if</span> <span class="n">to_reshape</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">theta_new</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
		<span class="k">return</span> <span class="n">theta_new</span></div>
	
<div class="viewcode-block" id="GW_generator.get_alpha_beta_gamma"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.GW_generator.get_alpha_beta_gamma">[docs]</a>	<span class="k">def</span> <span class="nf">get_alpha_beta_gamma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">t_grid</span><span class="p">,</span> <span class="n">f_ref</span><span class="p">,</span> <span class="n">singlespin</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Return the Euler angles alpha, beta and gamma as provided by the ML model.</span>
<span class="sd">		They are evaluated on the given time grid and the parameters refer to the frequency f_ref.</span>

<span class="sd">		Input:</span>
<span class="sd">			theta: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,8)/(8,) - source parameters to make prediction at (m1, m2, s1 (3,), s2 (3,))</span>
<span class="sd">			t_grid: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (D,) - a grid in (physical) time to evaluate the wave at (uses np.interp)</span>
<span class="sd">			f_ref: float</span>
<span class="sd">				reference frequency (in Hz) of the 22 mode at which the theta parameters refers to</span>
<span class="sd">			singlespin: bool</span>
<span class="sd">				whether to use the single spin approximation</span>
<span class="sd">		Output:</span>
<span class="sd">			alpha, beta, gamma: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N, D) - Euler angles</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="c1">#TODO: makes sure that theta has 2 dims!!</span>
		<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;/home/stefano/Dropbox/Stefano/PhD/mlgw_repository/precession/IMRPhenomTPHM/&#39;</span><span class="p">)</span> <span class="c1">#temporary, to load the IMRPhenomTPHM modes</span>
		<span class="kn">from</span> <span class="nn">run_IMR</span> <span class="kn">import</span> <span class="n">get_IMRPhenomTPHM_angles</span>
		<span class="kn">from</span> <span class="nn">precession_helper</span> <span class="kn">import</span> <span class="n">set_effective_spins</span>
		
		<span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_grid</span><span class="p">))),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_grid</span><span class="p">))),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_grid</span><span class="p">)))</span>
		
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">alpha</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
			<span class="n">m1</span><span class="p">,</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span>
			<span class="n">M_us</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">+</span> <span class="n">m2</span>
			<span class="n">M_std</span> <span class="o">=</span> <span class="mf">20.</span> <span class="c1">#DEBUG</span>
			<span class="n">ratio</span> <span class="o">=</span> <span class="n">M_std</span><span class="o">/</span><span class="n">M_us</span>
				<span class="c1">#computing the angles and performing the scaling</span>
				<span class="c1"># f1*M1 = f2*M2</span>
			<span class="n">chi1</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
			<span class="n">chi2</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">,[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]]</span>
			
			<span class="k">if</span> <span class="n">singlespin</span><span class="p">:</span>
				<span class="n">chi1</span><span class="p">,</span> <span class="n">chi2</span> <span class="o">=</span> <span class="n">set_effective_spins</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">chi1</span><span class="p">,</span> <span class="n">chi2</span><span class="p">)</span>
				
<span class="c1">#			print(&quot;Setting spins: &quot;,chi1, chi2)</span>
			<span class="n">t</span><span class="p">,</span> <span class="n">alpha_</span><span class="p">,</span> <span class="n">beta_</span><span class="p">,</span> <span class="n">gamma_</span> <span class="o">=</span> <span class="n">get_IMRPhenomTPHM_angles</span><span class="p">(</span><span class="n">m1</span><span class="o">*</span><span class="n">M_std</span><span class="o">/</span><span class="n">M_us</span><span class="p">,</span> <span class="n">m2</span><span class="o">*</span><span class="n">M_std</span><span class="o">/</span><span class="n">M_us</span><span class="p">,</span> <span class="o">*</span><span class="n">chi1</span><span class="p">,</span> <span class="o">*</span><span class="n">chi2</span><span class="p">,</span> <span class="n">f_ref</span><span class="o">*</span><span class="p">(</span><span class="n">M_us</span><span class="o">/</span><span class="n">M_std</span><span class="p">),</span> <span class="n">delta_T</span> <span class="o">=</span> <span class="mf">1e-4</span><span class="p">)</span>
			
			<span class="n">alpha</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">t_grid</span><span class="o">/</span><span class="n">M_us</span><span class="p">,</span> <span class="n">t</span><span class="o">/</span><span class="n">M_std</span><span class="p">,</span> <span class="n">alpha_</span><span class="p">)</span>
			<span class="n">beta</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">t_grid</span><span class="o">/</span><span class="n">M_us</span><span class="p">,</span> <span class="n">t</span><span class="o">/</span><span class="n">M_std</span><span class="p">,</span> <span class="n">beta_</span><span class="p">)</span>
			<span class="n">gamma</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">t_grid</span><span class="o">/</span><span class="n">M_us</span><span class="p">,</span> <span class="n">t</span><span class="o">/</span><span class="n">M_std</span><span class="p">,</span> <span class="n">gamma_</span><span class="p">)</span>
		
			<span class="c1">#integration of gamma (old)</span>
		<span class="c1">#alpha_dot = np.gradient(alpha,get_twisted_modes( t_grid, axis = 1) #(N,D)</span>
		<span class="c1">#gamma_prime = scipy.interpolate.interp1d(t_grid, np.multiply(alpha_dot, np.cos(beta)))</span>
		<span class="c1">#f_gamma_prime = lambda t, y : gamma_prime(t)</span>
		<span class="c1">#res_gamma = scipy.integrate.solve_ivp(f_gamma_prime, (t_grid[0],t_grid[-1]), [gamma0], t_eval = t_grid)</span>
		<span class="c1">#gamma = res_gamma[&#39;y&#39;]</span>
		
		<span class="k">return</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span></div>
		

<div class="viewcode-block" id="GW_generator.get_twisted_modes"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.GW_generator.get_twisted_modes">[docs]</a>	<span class="k">def</span> <span class="nf">get_twisted_modes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">t_grid</span><span class="p">,</span> <span class="n">modes</span><span class="p">,</span> <span class="n">f_ref</span> <span class="o">=</span> <span class="mf">20.</span><span class="p">,</span> <span class="n">alpha0</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">gamma0</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">L0_frame</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">singlespin</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Return the twisted modes of the model, evaluated in the given time grid.</span>
<span class="sd">		The twisted mode depends on angles alpha, beta, gamma and it is performed as in eqs. (17-20) in https://arxiv.org/abs/2005.05338</span>
<span class="sd">		The function returns the real and imaginary part of the twisted mode.</span>
<span class="sd">		Each mode is aligned s.t. the peak of the (untwisted) 22 mode is at t=0</span>
<span class="sd">		</span>
<span class="sd">		Input:</span>
<span class="sd">			theta: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,8)/(8,) -source parameters to make prediction at (m1, m2, s1 (3,), s2 (3,))</span>
<span class="sd">			t_grid: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (D&#39;,) -a grid in (physical) time to evaluate the wave at (uses np.interp)</span>
<span class="sd">			modes: list </span>
<span class="sd">				list (or a single tuple) of modes to be returned</span>
<span class="sd">			f_ref: float</span>
<span class="sd">				reference frequency (in Hz) of the 22 mode at which the theta parameters refers to</span>
<span class="sd">			L0_frame: bool</span>
<span class="sd">				whether to output the modes in the inertial L0_frame</span>
<span class="sd">			singlespin: bool</span>
<span class="sd">				whether to use the single spin approximation</span>
<span class="sd">		</span>
<span class="sd">		Output:</span>
<span class="sd">			real, imag:: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N, D&#39;, K) - real and imaginary part of the K modes required by the user (if mode is a tuple, no third dimension)</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="c1">#FIXME: here we have the serious issuf of the time at which L, S1, S2 are computed. It should be at a ref frequency or at the beginning of the time grid; but they are computed at a constant separation (which can be related to a frequency btw)</span>
		<span class="c1">#FIXME: we need to make clear at which parameters we generate the NP WFs. Now, if we only take the norm (no sign) we do not recover correctly the NP limit!! </span>
		<span class="c1">#FIXME: the merger frequency is really an issue!</span>
		<span class="c1">#FIXME: this function might have an error</span>

		<span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
		<span class="n">theta</span><span class="p">,</span> <span class="n">modes</span><span class="p">,</span> <span class="n">remove_first_dim</span><span class="p">,</span> <span class="n">remove_last_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_modes_input</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">modes</span><span class="p">)</span>
		<span class="n">theta_modes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_NP_theta</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
		
		<span class="k">if</span> <span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong number of orbital parameters to make predictions at. Expected 8 but </span><span class="si">{}</span><span class="s2"> given&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

		<span class="n">l_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">])</span> <span class="c1">#computing the set of l to take care of</span>
		<span class="n">h_P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">modes</span><span class="p">)),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span> <span class="c1">#(N,D,K) #output matrix of precessing modes</span>
		
			<span class="c1">#huge loop over l_list</span>
		<span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">l_list</span><span class="p">:</span>
			<span class="n">m_modes_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">lm</span> <span class="k">for</span> <span class="n">lm</span> <span class="ow">in</span> <span class="n">modes</span> <span class="k">if</span> <span class="n">lm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">l</span><span class="p">]</span> <span class="c1">#len = M #list of the twisted lm modes (with constant l) required by the user</span>
			
				<span class="c1">#genereting the non-precessing l-modes available</span>
			<span class="n">mprime_modes_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">lm</span>  <span class="k">for</span> <span class="n">lm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_modes</span><span class="p">()</span> <span class="k">if</span> <span class="n">lm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">l</span><span class="p">]</span> <span class="c1">#NP modes generated by mlgw #len = M&#39;</span>
			<span class="n">l_modes_p</span><span class="p">,</span> <span class="n">l_modes_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_modes</span><span class="p">(</span><span class="n">theta_modes</span><span class="p">,</span> <span class="n">t_grid</span><span class="p">,</span> <span class="n">mprime_modes_list</span><span class="p">,</span> <span class="n">out_type</span> <span class="o">=</span> <span class="s2">&quot;realimag&quot;</span><span class="p">)</span> <span class="c1">#(N,D,M&#39;)</span>
			<span class="n">h_NP_l</span> <span class="o">=</span> <span class="n">l_modes_p</span> <span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span> <span class="n">l_modes_c</span> <span class="c1">#(N,D,M&#39;) #awful using complex numbers but necessary</span>
			
				<span class="c1">#adding negative m modes</span>
			<span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mprime_modes_list</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
			<span class="n">h_NP_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">h_NP_l</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">h_NP_l</span><span class="p">[:,:,</span><span class="n">ids</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">l</span><span class="p">)],</span> <span class="n">axis</span> <span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#(N,D,M&#39;&#39;)</span>
			<span class="n">mprime_modes_list</span> <span class="o">=</span> <span class="n">mprime_modes_list</span> <span class="o">+</span> <span class="p">[(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mprime_modes_list</span> <span class="k">if</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="c1">#len = M&#39;&#39;</span>
			
				<span class="c1">#getting alpha, beta, gamma</span>
			<span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_alpha_beta_gamma</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">t_grid</span><span class="p">,</span> <span class="n">f_ref</span><span class="p">,</span> <span class="n">singlespin</span><span class="p">)</span>
			
			<span class="k">if</span> <span class="n">alpha0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">alpha0</span> 
			<span class="k">if</span> <span class="n">gamma0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span> <span class="o">-</span> <span class="n">gamma</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">gamma0</span>
			
				<span class="c1">#OLD way: with TEOB conventions</span>
			<span class="c1">#D_mprimem = self.__get_Wigner_D_matrix(l,[lm[1] for lm in mprime_modes_list], [lm[1] for lm in m_modes_list], -gamma, -beta, -alpha) #(N,D,M&#39;&#39;,M)</span>
			<span class="c1">#D_mprimem = np.conj(D_mprimem) #(N,D,M&#39;&#39;,M) #complex conjugate</span>
			<span class="c1">#h_P_l = np.einsum(&#39;ijkl,ijk-&gt;ijl&#39;, D_mprimem, h_NP_l) #(N,D,M)</span>
			
				<span class="c1">#computing Wigner D matrix Dmm&#39;(alpha, beta, gamma)</span>
			<span class="n">D_mmprime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_Wigner_D_matrix</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="p">[</span><span class="n">lm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">lm</span> <span class="ow">in</span> <span class="n">m_modes_list</span><span class="p">],</span> <span class="p">[</span><span class="n">lm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">lm</span> <span class="ow">in</span> <span class="n">mprime_modes_list</span><span class="p">],</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span> <span class="c1">#(N,D,M, M&#39;&#39;)</span>
			
				<span class="c1">#putting everything together</span>
				<span class="c1">#h_lm(t) = D_mm&#39;(t) h_lm&#39;</span>
			<span class="n">h_P_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijlk,ijk-&gt;ijl&#39;</span><span class="p">,</span> <span class="n">D_mmprime</span><span class="p">,</span> <span class="n">h_NP_l</span><span class="p">)</span> <span class="c1">#(N,D,M)</span>
			
				<span class="c1">#twist the system to the L0 frame (if it is the case)</span>
			<span class="k">if</span> <span class="n">L0_frame</span><span class="p">:</span>
				<span class="c1">#TODO: set alpha_ref etc...</span>
				<span class="n">alpha_ref</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
				<span class="n">beta_ref</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
				<span class="n">gamma_ref</span> <span class="o">=</span> <span class="n">gamma</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
				<span class="n">D_mmprime_L0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_Wigner_D_matrix</span><span class="p">(</span><span class="n">l</span><span class="p">,[</span><span class="n">lm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">lm</span> <span class="ow">in</span> <span class="n">m_modes_list</span><span class="p">],</span> <span class="p">[</span><span class="n">lm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">lm</span> <span class="ow">in</span> <span class="n">m_modes_list</span><span class="p">],</span>  <span class="o">-</span><span class="n">gamma_ref</span><span class="p">,</span> <span class="o">-</span><span class="n">beta_ref</span><span class="p">,</span> <span class="o">-</span><span class="n">alpha_ref</span><span class="p">)</span> <span class="c1">#(N,M,M&#39;)</span>
				<span class="n">h_P_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ilk,ijk -&gt; ijl&#39;</span><span class="p">,</span> <span class="n">D_mmprime_L0</span><span class="p">,</span> <span class="n">h_P_l</span><span class="p">)</span>
			
				<span class="c1">#saving the results in the output matrix</span>
			<span class="n">ids_l</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">modes</span><span class="p">)</span> <span class="k">if</span> <span class="n">lm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">l</span><span class="p">]</span>
			<span class="n">h_P</span><span class="p">[:,:,</span><span class="n">ids_l</span><span class="p">]</span> <span class="o">=</span> <span class="n">h_P_l</span>
			
		<span class="k">if</span> <span class="n">remove_last_dim</span><span class="p">:</span>
			<span class="n">h_P</span> <span class="o">=</span> <span class="n">h_P</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#(N,D)</span>
		<span class="k">if</span> <span class="n">remove_first_dim</span><span class="p">:</span>
			<span class="n">h_P</span> <span class="o">=</span> <span class="n">h_P</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="c1">#(D,)/(D,K)</span>
		<span class="k">return</span> <span class="n">h_P</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">h_P</span><span class="o">.</span><span class="n">imag</span></div>

	<span class="c1">#@do_profile()</span>
	<span class="k">def</span> <span class="nf">__get_WF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">t_grid</span><span class="p">,</span> <span class="n">modes</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Generates the waves in time domain, building it as a sum of modes weighted by spherical harmonics. Called by get_WF.</span>
<span class="sd">		Accepts only input features as [q,s1,s2] or [m1, m2, spin1_z , spin2_z, D_L, inclination, phi_0].</span>

<span class="sd">		Input:</span>
<span class="sd">			theta: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (D,)/(N,D) - source parameters to make prediction at (D=7)</span>
<span class="sd">			t_grid: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (D&#39;,) - a grid in (reduced) time to evaluate the wave at (uses np.interp)</span>
<span class="sd">			modes: list</span>
<span class="sd">				list of modes employed for building the WF (if None, every mode available is employed)</span>
<span class="sd">		Ouput:</span>
<span class="sd">			h_plus, h_cross: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (D,)/(N,D) - desidered polarizations (if it applies)</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">D</span><span class="o">=</span> <span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#number of features given</span>
		<span class="k">assert</span> <span class="n">D</span> <span class="o">==</span> <span class="mi">7</span>

			<span class="c1">#computing amplitude prefactor</span>
		<span class="n">prefactor</span> <span class="o">=</span> <span class="mf">4.7864188273360336e-20</span> <span class="c1"># G/c^2*(M_sun/Mpc)</span>
		<span class="n">m_tot_us</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">theta</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>	<span class="c1">#total mass in solar masses for the user  (N,)</span>
		<span class="n">amp_prefactor</span> <span class="o">=</span> <span class="n">prefactor</span><span class="o">*</span><span class="n">m_tot_us</span><span class="o">/</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]</span> <span class="c1"># G/c^2 (M / d_L) </span>

		<span class="n">h_plus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">t_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="n">h_cross</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">t_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

			<span class="c1">#if only mode 22 is required, it is treated separately for speed up	</span>
		<span class="k">if</span> <span class="n">modes</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span><span class="c1"># or modes == [(2,2)]:</span>
			<span class="n">amp_22</span><span class="p">,</span> <span class="n">ph_22</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mode_dict</span><span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)]]</span><span class="o">.</span><span class="n">get_mode</span><span class="p">(</span><span class="n">theta</span><span class="p">[:,:</span><span class="mi">4</span><span class="p">],</span> <span class="n">t_grid</span><span class="p">,</span> <span class="n">out_type</span> <span class="o">=</span> <span class="s2">&quot;ampph&quot;</span><span class="p">)</span>
			<span class="n">amp_22</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="o">/</span><span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">amp_22</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">amp_prefactor</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="c1">#G/c^2*(M_sun/Mpc) nu *(M/M_sun)/(d_L/Mpc)</span>
				<span class="c1">#setting spherical harmonics by hand</span>
			<span class="n">c_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">5</span><span class="p">])</span> <span class="c1">#(N,)</span>
			<span class="n">h_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">amp_22</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ph_22</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">6</span><span class="p">])),</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">c_i</span><span class="p">))</span> <span class="p">)</span><span class="o">.</span><span class="n">T</span>
			<span class="n">h_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">amp_22</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ph_22</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">6</span><span class="p">])),</span> <span class="n">c_i</span> <span class="p">)</span><span class="o">.</span><span class="n">T</span>
			<span class="k">return</span> <span class="n">h_p</span><span class="p">,</span> <span class="n">h_c</span>

		<span class="k">if</span> <span class="n">modes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">modes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_modes</span><span class="p">()</span>

		<span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">:</span>
			<span class="k">try</span><span class="p">:</span>	
				<span class="n">mode_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode_dict</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
			<span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
				<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Unable to find mode </span><span class="si">{}</span><span class="s2">: mode might be non existing or in the wrong format. Skipping it&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
				<span class="k">continue</span>
				
			<span class="n">amp_lm</span><span class="p">,</span> <span class="n">ph_lm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="p">[</span><span class="n">mode_id</span><span class="p">]</span><span class="o">.</span><span class="n">get_mode</span><span class="p">(</span><span class="n">theta</span><span class="p">[:,:</span><span class="mi">4</span><span class="p">],</span> <span class="n">t_grid</span><span class="p">,</span> <span class="n">out_type</span> <span class="o">=</span> <span class="s2">&quot;ampph&quot;</span><span class="p">)</span>
			<span class="n">amp_lm</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">amp_lm</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">amp_prefactor</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="c1">#G/c^2*(M_sun/Mpc) nu *(M/M_sun)/(d_L/Mpc)</span>
				<span class="c1"># setting spherical harmonics: amp, ph, D_L,iota, phi_0</span>
			<span class="n">h_lm_real</span><span class="p">,</span> <span class="n">h_lm_imag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__set_spherical_harmonics</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">amp_lm</span><span class="p">,</span> <span class="n">ph_lm</span><span class="p">,</span> <span class="n">theta</span><span class="p">[:,</span><span class="mi">5</span><span class="p">],</span> <span class="n">theta</span><span class="p">[:,</span><span class="mi">6</span><span class="p">])</span>
			<span class="n">h_plus</span> <span class="o">=</span> <span class="n">h_plus</span> <span class="o">+</span> <span class="n">h_lm_real</span>
			<span class="n">h_cross</span> <span class="o">=</span> <span class="n">h_cross</span> <span class="o">+</span> <span class="n">h_lm_imag</span>

		<span class="k">return</span> <span class="n">h_plus</span><span class="p">,</span> <span class="n">h_cross</span>

<div class="viewcode-block" id="GW_generator.get_modes"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.GW_generator.get_modes">[docs]</a>	<span class="k">def</span> <span class="nf">get_modes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">t_grid</span><span class="p">,</span> <span class="n">modes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">out_type</span> <span class="o">=</span> <span class="s2">&quot;ampph&quot;</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Return the modes in the model, evaluated in the given time grid.</span>
<span class="sd">		It can return amplitude and phase (out_type = &quot;ampph&quot;) or the real and imaginary part (out_type = &quot;realimag&quot;).</span>
<span class="sd">		Each mode is aligned s.t. the peak of the 22 mode is at t=0</span>
<span class="sd">	</span>
<span class="sd">		Input:</span>
<span class="sd">			theta: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (D,)/(N,D) - source parameters to make prediction at (D = 3,4)</span>
<span class="sd">			t_grid: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (D&#39;,) - a grid in time to evaluate the wave at (uses np.interp)</span>
<span class="sd">			modes: list</span>
<span class="sd">				list of modes to be returned (if None, every mode available is employed)</span>
<span class="sd">			out_type: bool</span>
<span class="sd">				whether amplitude and phase (&quot;ampph&quot;) or real and imaginary part (&quot;realimag&quot;) shall be returned</span>
<span class="sd">	</span>
<span class="sd">		Output:</span>
<span class="sd">			amp, ph: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N, D&#39;, K) - amplitude and phase of the K modes required by the user (if K =1, no third dimension)</span>
<span class="sd">			real, imag: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N, D&#39;, K) - real and imaginary part of the K modes required by the user (if K =1, no third dimension)</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">out_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;realimag&quot;</span><span class="p">,</span> <span class="s2">&quot;ampph&quot;</span><span class="p">]:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong output type chosen. Expected </span><span class="se">\&quot;</span><span class="s2">realimag</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">ampph</span><span class="se">\&quot;</span><span class="s2">, given </span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="o">+</span><span class="n">out_type</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>

		<span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
		<span class="n">theta</span><span class="p">,</span> <span class="n">modes</span><span class="p">,</span> <span class="n">remove_first_dim</span><span class="p">,</span> <span class="n">remove_last_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_modes_input</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">modes</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
			<span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[:,:</span><span class="mi">4</span><span class="p">]</span>
		<span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">modes</span><span class="p">)</span>

		<span class="n">res1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">t_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">K</span><span class="p">))</span>
		<span class="n">res2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">t_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">K</span><span class="p">))</span>

			<span class="c1">#old version (worse)</span>
		<span class="c1">#for mode in self.modes:	</span>
		<span class="c1">#	if mode.lm() not in modes: #skipping a non-necessary mode</span>
		<span class="c1">#		continue</span>
		<span class="c1">#	else: #computing index to save the mode at</span>
		<span class="c1">#		i = modes.index(mode.lm())</span>
		<span class="c1">#	res1[:,:,i], res2[:,:,i] = mode.get_mode(theta, t_grid, out_type = out_type)</span>

		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">modes</span><span class="p">):</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="n">mode_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode_dict</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
			<span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
				<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Unable to find mode </span><span class="si">{}</span><span class="s2">: mode might be non existing or in the wrong format. Skipping it&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
				<span class="k">continue</span>
			<span class="n">res1</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">],</span> <span class="n">res2</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="p">[</span><span class="n">mode_id</span><span class="p">]</span><span class="o">.</span><span class="n">get_mode</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">t_grid</span><span class="p">,</span> <span class="n">out_type</span> <span class="o">=</span> <span class="n">out_type</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">remove_last_dim</span><span class="p">:</span>
			<span class="n">res1</span><span class="p">,</span> <span class="n">res2</span> <span class="o">=</span> <span class="n">res1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">res2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#(N,D)</span>
		<span class="k">if</span> <span class="n">remove_first_dim</span><span class="p">:</span>
			<span class="n">res1</span><span class="p">,</span> <span class="n">res2</span> <span class="o">=</span> <span class="n">res1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> <span class="n">res2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="c1">#(D,)/(D,K)</span>
		<span class="k">return</span> <span class="n">res1</span><span class="p">,</span> <span class="n">res2</span></div>
		
<div class="viewcode-block" id="GW_generator.get_spherical_harmonics"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.GW_generator.get_spherical_harmonics">[docs]</a>	<span class="k">def</span> <span class="nf">get_spherical_harmonics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">iota</span><span class="p">,</span> <span class="n">phi_0</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Computes the sperical harmonics.</span>
<span class="sd">		We parametrize: Y_lm(iota, phi_0) = d_lm(iota) * exp(i*m*phi_0)</span>
<span class="sd">		</span>
<span class="sd">		Input:</span>
<span class="sd">			mode: tuple</span>
<span class="sd">				(l,m) of the current mode</span>
<span class="sd">			iota: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,) - inclination for each wave</span>
<span class="sd">			phi_0: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,) - reference phase for each wave</span>

<span class="sd">		Output:</span>
<span class="sd">			Y_lm_real, Y_lm_imag: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,D) - real and imaginary part of the spherical harmonics</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">iota</span><span class="p">,</span> <span class="n">phi_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">iota</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">phi_0</span><span class="p">)</span>
		<span class="n">l</span><span class="p">,</span><span class="n">m</span> <span class="o">=</span> <span class="n">mode</span>
			<span class="c1">#computing the iota dependence of the WF</span>
		<span class="n">d_lm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_Wigner_d_function</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="o">-</span><span class="n">m</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">iota</span><span class="p">)</span> <span class="c1">#(N,)</span>
		<span class="n">const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
		<span class="n">Y_lm</span> <span class="o">=</span> <span class="n">const</span><span class="o">*</span><span class="n">d_lm</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">phi_0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">Y_lm</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">Y_lm</span><span class="o">.</span><span class="n">imag</span></div>
	
	<span class="c1">#@do_profile(follow=[])</span>
	<span class="k">def</span> <span class="nf">__set_spherical_harmonics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">amp</span><span class="p">,</span> <span class="n">ph</span><span class="p">,</span> <span class="n">iota</span><span class="p">,</span> <span class="n">phi_0</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Given amplitude and phase of a mode, it returns the quantity [Y_lm*A*e^(i*ph)+ Y_l-m*A*e^(-i*ph)]. This amounts to the contribution to the WF given by the mode.</span>
<span class="sd">		We parametrize: math:`Y_{lm}(iota, phi_0) = d_lm(iota) * exp(i*m*phi_0)`</span>
<span class="sd">		It also include negative m modes with: :math:`h_{lm} = (-1)**l h*_{l-m}` (`1501.00918 &lt;https://arxiv.org/abs/1501.00918&gt;`_ eq. (5))</span>

<span class="sd">		Input:</span>
<span class="sd">			mode: tuple</span>
<span class="sd">				(l,m) of the current mode</span>
<span class="sd">			amp, ph: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (D,)/(N,D) - amplitude and phase of the WFs (as generated by the ML)</span>
<span class="sd">			iota: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (,)/(N,) - inclination for each wave</span>
<span class="sd">			phi_0: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (,)/(N,) - reference phase for each wave</span>
<span class="sd">		Output:</span>
<span class="sd">			h_lm_real, h_lm_imag (N,D)	processed strain, with d, iota, phi_0 dependence included.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="c1">#FIXME: check if this is correct!</span>
		<span class="c1">#To generate the modes as TPHM:</span>
		<span class="c1">#	https://git.ligo.org/lscsoft/lalsuite/-/blob/master/lalsimulation/lib/LALSimIMRPhenomTPHM.c#L248</span>
		<span class="c1">#Add mode in lal:</span>
		<span class="c1">#	https://git.ligo.org/lscsoft/lalsuite/-/blob/master/lalsimulation/lib/LALSimSphHarmMode.c#L44</span>
		
		<span class="n">l</span><span class="p">,</span><span class="n">m</span> <span class="o">=</span> <span class="n">mode</span>
			<span class="c1">#computing the iota dependence of the WF</span>
		<span class="n">d_lm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_Wigner_d_function</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="o">-</span><span class="n">m</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">iota</span><span class="p">)</span> <span class="c1">#(N,)</span>
		<span class="n">d_lmm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_Wigner_d_function</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">iota</span><span class="p">)</span> <span class="c1">#(N,)</span>
		<span class="n">const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">m</span>
		<span class="n">parity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">l</span><span class="p">)</span> <span class="c1">#are you sure of that? apparently yes...</span>

			<span class="c1">#FIXME: this can be done better interpolating after the spherical harmonic multiplication</span>
		<span class="n">h_lm_real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">amp</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ph</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="n">m</span><span class="o">*</span><span class="n">phi_0</span><span class="p">)),</span> <span class="n">const</span><span class="o">*</span><span class="p">(</span><span class="n">d_lm</span> <span class="o">+</span> <span class="n">parity</span> <span class="o">*</span> <span class="n">d_lmm</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="c1">#(N,D)</span>
		<span class="n">h_lm_imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">amp</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ph</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="n">m</span><span class="o">*</span><span class="n">phi_0</span><span class="p">)),</span> <span class="n">const</span><span class="o">*</span><span class="p">(</span><span class="n">d_lm</span> <span class="o">-</span> <span class="n">parity</span> <span class="o">*</span> <span class="n">d_lmm</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="c1">#(N,D)</span>

		<span class="k">return</span> <span class="n">h_lm_real</span><span class="p">,</span> <span class="n">h_lm_imag</span>

	<span class="k">def</span> <span class="nf">__get_Wigner_d_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">iota</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Return the general Wigner d function (or small Wigner matrix).</span>
<span class="sd">		See eq. (16-18) of https://arxiv.org/pdf/2005.05338.pdf for an explicit expression.</span>
<span class="sd">		</span>
<span class="sd">		Input:</span>
<span class="sd">			l: int</span>
<span class="sd">				l parameter</span>
<span class="sd">			n,m: int</span>
<span class="sd">				matrix elements</span>
<span class="sd">			iota: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape ()/(N,) - angle to evaluate the function at</span>
<span class="sd">		Output:</span>
<span class="sd">			d_lms: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape ()/(N,) - Amplitude of the spherical harmonics d_lm(iota)</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">d_lnm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">iota</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1">#(N,)</span>
    
		<span class="n">cos_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">iota</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span> <span class="c1">#(N,)</span>
		<span class="n">sin_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">iota</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span> <span class="c1">#(N,)</span>
    
			<span class="c1">#starting computation (sloooow??)</span>
		<span class="n">ki</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="n">n</span><span class="p">)</span>
		<span class="n">kf</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="o">-</span><span class="n">n</span><span class="p">)</span>
		   	
		<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ki</span><span class="p">,</span><span class="n">kf</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
			<span class="n">norm</span> <span class="o">=</span> <span class="n">fact</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">fact</span><span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">m</span><span class="o">-</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">fact</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="n">n</span><span class="o">-</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">fact</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="o">+</span><span class="n">k</span><span class="p">)</span> <span class="c1">#normalization constant</span>
			<span class="n">d_lnm</span> <span class="o">=</span> <span class="n">d_lnm</span> <span class="o">+</span>  <span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">cos_i</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">l</span><span class="o">+</span><span class="n">m</span><span class="o">-</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">sin_i</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="p">)</span> <span class="p">)</span> <span class="o">/</span> <span class="n">norm</span>

		<span class="n">const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">fact</span><span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="n">fact</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="n">m</span><span class="p">)</span> <span class="o">*</span> <span class="n">fact</span><span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">fact</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="n">n</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">const</span><span class="o">*</span><span class="n">d_lnm</span>
	
	<span class="k">def</span> <span class="nf">__get_Wigner_D_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m_prime</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Return the general Wigner D matrix. It takes in input l,n,m and the angles (might be time dependent)</span>
<span class="sd">		For an explicit expression, see eq. (3.4) in https://arxiv.org/pdf/2004.06503.pdf or eq. (36-37) in https://arxiv.org/pdf/2004.08302.pdf</span>
<span class="sd">		See also: (2.8) in https://dcc.ligo.org/LIGO-T2000446</span>
<span class="sd">		</span>
<span class="sd">		Input:</span>
<span class="sd">			l: int</span>
<span class="sd">				l parameter</span>
<span class="sd">			m_prime, m: list</span>
<span class="sd">				list of required matrix elements (of length M&#39; and M)</span>
<span class="sd">			alpha: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,)/(N,D) - Euler angle alpha</span>
<span class="sd">			beta: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,)/(N,D) -Euler angle beta</span>
<span class="sd">			alpha: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,)/(N,D) -Euler angle gamma</span>
<span class="sd">		Output:</span>
<span class="sd">			D_lms: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,D,M&#39;,M)/(N,M&#39;,M) - Wigner D matrix</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="c1">#FIXME:check over the sign of exp(1j*alpha), exp(1j*gamma)!! There is an ambiguity...</span>
		<span class="k">if</span> <span class="n">alpha</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
			<span class="n">beta</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
			<span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
			<span class="n">squeeze</span> <span class="o">=</span> <span class="kc">True</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">squeeze</span> <span class="o">=</span> <span class="kc">False</span>
		
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m_prime</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span> <span class="n">m_prime</span> <span class="o">=</span> <span class="p">[</span><span class="n">m_prime</span><span class="p">]</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span> <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="p">]</span>
		
		<span class="n">D_mprimem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">alpha</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alpha</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">m_prime</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)))</span> <span class="c1">#(N,D, M&#39;, M)</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m_prime_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">m_prime</span><span class="p">):</span>
			<span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">m_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
				<span class="n">D_mprimem</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_Wigner_d_function</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">m_prime_</span><span class="p">,</span> <span class="n">m_</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span> <span class="c1">#(N,D)</span>
			
			<span class="c1">#computing exp(-1j*m*alpha)</span>
		<span class="n">exp_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,k-&gt;ijk&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">m_prime</span><span class="p">))</span> <span class="c1">#(N,D,M&#39;)</span>
		<span class="n">exp_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">exp_alpha</span><span class="p">)</span> <span class="c1">#(N,D,M)</span>

			<span class="c1">#computing exp(1j*m&#39;*gamma)</span>
		<span class="n">exp_gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,k-&gt;ijk&#39;</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="c1">#(N,D,M)</span>
		<span class="n">exp_gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">exp_gamma</span><span class="p">)</span> <span class="c1">#(N,D,M&#39;&#39;)</span>
			
			<span class="c1">#putting everything together</span>
		<span class="n">exp_term</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,ijl-&gt;ijkl&#39;</span><span class="p">,</span><span class="n">exp_alpha</span><span class="p">,</span> <span class="n">exp_gamma</span><span class="p">)</span> <span class="c1">#(N,D, M&#39;, M)</span>
		<span class="n">D_mprimem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">D_mprimem</span><span class="p">,</span><span class="n">exp_term</span><span class="p">)</span>
		
		<span class="k">if</span> <span class="n">squeeze</span><span class="p">:</span> <span class="k">return</span> <span class="n">D_mprimem</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,:,:]</span>
		<span class="k">return</span> <span class="n">D_mprimem</span>
	
<div class="viewcode-block" id="GW_generator.get_mode_obj"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.GW_generator.get_mode_obj">[docs]</a>	<span class="k">def</span> <span class="nf">get_mode_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns an instance of class mode_generator which hold the ML model for the required mode.</span>

<span class="sd">		Input:</span>
<span class="sd">			mode: tuple</span>
<span class="sd">				(l,m) of the required mode</span>

<span class="sd">		Output:</span>
<span class="sd">			mode_obj: :class:`mode_generator_base`</span>
<span class="sd">				instance of mode_generator (depending on the model it can be :class:`mode_generator_NN` or :class:`mode_generator_MoE`)</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">for</span> <span class="n">mode_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="p">:</span>	
			<span class="k">if</span> <span class="n">mode_</span><span class="o">.</span><span class="n">lm</span><span class="p">()</span> <span class="o">==</span> <span class="n">mode</span><span class="p">:</span> <span class="c1">#check if it is the correct mode</span>
				<span class="k">return</span> <span class="n">mode_</span>
		<span class="k">return</span> <span class="kc">None</span></div>
		
<div class="viewcode-block" id="GW_generator.get_mode_grads"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.GW_generator.get_mode_grads">[docs]</a>	<span class="k">def</span> <span class="nf">get_mode_grads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">t_grid</span><span class="p">,</span> <span class="n">modes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">out_type</span> <span class="o">=</span> <span class="s2">&quot;ampph&quot;</span><span class="p">,</span> <span class="n">grad_var</span> <span class="o">=</span> <span class="s1">&#39;M_q&#39;</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Return the gradients of the GW higher order modes in the model; the gradients are evaluated on the given time grid.</span>
<span class="sd">		It can return the gradient of the amplitude and phase (out_type = &quot;ampph&quot;) or the gradient of the real and imaginary part (out_type = &quot;realimag&quot;).</span>
<span class="sd">		</span>
<span class="sd">		Depending on `grad_var`, gradients w.r.t. to different quantities are computed:</span>
<span class="sd">		</span>
<span class="sd">		- if grad_var = &#39;M_q&#39;, [M,q,s1,s2]</span>
<span class="sd">		</span>
<span class="sd">		- if grad_var = &#39;mchirp_eta&#39;, [Mc,eta,s1,s2]</span>
<span class="sd">		</span>
<span class="sd">		- if grad_var = &#39;m1_m2&#39;, [m1,m2,s1,s2]</span>

<span class="sd">		They are returned in this order for each point of the time grid.</span>

<span class="sd">		Input:</span>
<span class="sd">			theta: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,)/(N,D) - source parameters to make prediction at (D = 4)</span>
<span class="sd">			t_grid: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (D&#39;,) - a grid in time to evaluate the wave at (uses np.interp)</span>
<span class="sd">			modes: list</span>
<span class="sd">				list of modes to be returned (if None, every mode available is employed)</span>
<span class="sd">			out_type: str</span>
<span class="sd">				whether amplitude and phase (&quot;ampph&quot;) or real and imaginary part (&quot;realimag&quot;) shall be returned</span>
<span class="sd">			grad_var: str</span>
<span class="sd">				the variables which the gradients are computed w.r.t.</span>
<span class="sd">		</span>
<span class="sd">		Output:</span>
<span class="sd">			grad_amp, grad_ph: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N, D&#39;, 4, K) - amplitude and phase of the K modes, if queried by the user</span>
<span class="sd">			grad_real, grad_imag: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N, D&#39;, 4, K) - real and imaginary part of the K modes, if queried by the user</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">out_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;realimag&quot;</span><span class="p">,</span> <span class="s2">&quot;ampph&quot;</span><span class="p">]:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong output type chosen. Expected </span><span class="se">\&quot;</span><span class="s2">realimag</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">ampph</span><span class="se">\&quot;</span><span class="s2">, given </span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="o">+</span><span class="n">out_type</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">grad_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;M_q&quot;</span><span class="p">,</span> <span class="s2">&quot;mchirp_eta&quot;</span><span class="p">,</span> <span class="s2">&quot;m1_m2&quot;</span><span class="p">]:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong gradient variables chosen. Expected </span><span class="se">\&quot;</span><span class="s2">M_q</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">mchirp_eta</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">m1_m2</span><span class="se">\&quot;</span><span class="s2">; given </span><span class="se">\&quot;</span><span class="si">{}</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">grad_var</span><span class="p">))</span>

		<span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
		<span class="n">theta</span><span class="p">,</span> <span class="n">modes</span><span class="p">,</span> <span class="n">remove_first_dim</span><span class="p">,</span> <span class="n">remove_last_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_modes_input</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">modes</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">grad_var</span> <span class="o">==</span> <span class="s1">&#39;mchirp_eta&#39;</span><span class="p">:</span>
			<span class="n">dq_deta</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">mchirp</span><span class="p">,</span> <span class="n">eta</span><span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">eta</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">eta</span><span class="p">))</span><span class="o">+</span><span class="mf">0.5</span><span class="o">/</span><span class="n">eta</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">eta</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">eta</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
			<span class="n">dM_dmchirp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">mchirp</span><span class="p">,</span> <span class="n">eta</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.</span><span class="o">/</span><span class="mf">5.</span><span class="p">)</span>
			<span class="n">dM_deta</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">mchirp</span><span class="p">,</span> <span class="n">eta</span><span class="p">:</span> <span class="o">-</span><span class="mf">3.</span><span class="o">/</span><span class="mf">5.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">mchirp</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="o">-</span><span class="mf">8.</span><span class="o">/</span><span class="mf">5.</span><span class="p">))</span>
			<span class="n">mchirp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="mf">3.</span><span class="o">/</span><span class="mf">5.</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="mf">1.</span><span class="o">/</span><span class="mf">5.</span><span class="p">)</span> <span class="c1">#chirp mass</span>
			<span class="n">eta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]))</span> <span class="c1">#chirp mass</span>
			
			<span class="n">Jac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
			<span class="n">Jac</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dM_dmchirp</span><span class="p">(</span><span class="n">mchirp</span><span class="p">,</span> <span class="n">eta</span><span class="p">)</span>
			<span class="n">Jac</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dM_deta</span><span class="p">(</span><span class="n">mchirp</span><span class="p">,</span> <span class="n">eta</span><span class="p">)</span>
			<span class="n">Jac</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dq_deta</span><span class="p">(</span><span class="n">mchirp</span><span class="p">,</span> <span class="n">eta</span><span class="p">)</span>
			<span class="c1">#Jac[:,0,1] = dq/dmchirp = 0</span>

		<span class="k">if</span> <span class="n">grad_var</span> <span class="o">==</span> <span class="s1">&#39;m1_m2&#39;</span><span class="p">:</span>
			<span class="n">dq_dm1</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">m1</span><span class="p">,</span><span class="n">m2</span><span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="n">m2</span>
			<span class="n">dq_dm2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">m1</span><span class="p">,</span><span class="n">m2</span><span class="p">:</span> <span class="o">-</span><span class="n">m1</span><span class="o">/</span><span class="n">m2</span><span class="o">**</span><span class="mi">2</span>
				<span class="c1">#switchin m1/m2 wherever needed</span>
			<span class="n">ids_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
			<span class="n">ids_ok</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
			
			<span class="n">Jac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
			<span class="n">Jac</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span> <span class="c1">#dM_dm1</span>
			<span class="n">Jac</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span> <span class="c1">#dM_dm2</span>
			<span class="n">Jac</span><span class="p">[</span><span class="n">ids_ok</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dq_dm1</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">ids_ok</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">theta</span><span class="p">[</span><span class="n">ids_ok</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
			<span class="n">Jac</span><span class="p">[</span><span class="n">ids_ok</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dq_dm2</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">ids_ok</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">theta</span><span class="p">[</span><span class="n">ids_ok</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>

			<span class="n">Jac</span><span class="p">[</span><span class="n">ids_inv</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dq_dm2</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">ids_inv</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">theta</span><span class="p">[</span><span class="n">ids_inv</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">Jac</span><span class="p">[</span><span class="n">ids_inv</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dq_dm1</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">ids_inv</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">theta</span><span class="p">[</span><span class="n">ids_inv</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
			
			
		<span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">modes</span><span class="p">)</span>

		<span class="n">res1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">t_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">4</span><span class="p">,</span><span class="n">K</span><span class="p">))</span>
		<span class="n">res2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">t_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">4</span><span class="p">,</span><span class="n">K</span><span class="p">))</span>

		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">modes</span><span class="p">):</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="n">mode_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode_dict</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
			<span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
				<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Unable to find mode </span><span class="si">{}</span><span class="s2">: mode might be non existing or in the wrong format. Skipping it&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
				<span class="k">continue</span>
			<span class="n">res1</span><span class="p">[:,:,:,</span><span class="n">i</span><span class="p">],</span> <span class="n">res2</span><span class="p">[:,:,:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="p">[</span><span class="n">mode_id</span><span class="p">]</span><span class="o">.</span><span class="n">get_grads</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">t_grid</span><span class="p">,</span> <span class="n">out_type</span> <span class="o">=</span> <span class="n">out_type</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">grad_var</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;m1_m2&#39;</span><span class="p">,</span> <span class="s1">&#39;mchirp_eta&#39;</span><span class="p">]:</span>
			<span class="n">res1</span><span class="p">[:,:,:</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijkl,imk -&gt; ijml&#39;</span><span class="p">,</span> <span class="n">res1</span><span class="p">[:,:,:</span><span class="mi">2</span><span class="p">,:],</span> <span class="n">Jac</span><span class="p">)</span>
			<span class="n">res2</span><span class="p">[:,:,:</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijkl,imk -&gt; ijml&#39;</span><span class="p">,</span> <span class="n">res2</span><span class="p">[:,:,:</span><span class="mi">2</span><span class="p">,:],</span> <span class="n">Jac</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">remove_last_dim</span><span class="p">:</span>
			<span class="n">res1</span><span class="p">,</span> <span class="n">res2</span> <span class="o">=</span> <span class="n">res1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">res2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#(N,D)</span>
		<span class="k">if</span> <span class="n">remove_first_dim</span><span class="p">:</span>
			<span class="n">res1</span><span class="p">,</span> <span class="n">res2</span> <span class="o">=</span> <span class="n">res1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> <span class="n">res2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="c1">#(D,)/(D,K)</span>
		<span class="k">return</span> <span class="n">res1</span><span class="p">,</span> <span class="n">res2</span></div></div>
	
<div class="viewcode-block" id="mode_generator_base"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.mode_generator_base">[docs]</a><span class="k">class</span> <span class="nc">mode_generator_base</span><span class="p">():</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Base class for the mode generator.</span>
<span class="sd">	All modes generator should inherit from it and implement methods ``load``, ``get_raw_mode``. If gradients are needed, it must implement ``get_raw_grads``.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">folder</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Initialise class by loading models from a given folder.</span>
<span class="sd">		Everything useful for the model must be put within the folder with the standard names, readable by ``load``.</span>
<span class="sd">		A compulsory file times must hold a list of grid points at which the generated ML wave is evaluated.</span>
<span class="sd">		An optional README file holds more information about the model (in the format of a dictionary).</span>
<span class="sd">		</span>
<span class="sd">		Input:</span>
<span class="sd">			mode: tuple</span>
<span class="sd">				tuple (l,m) of the mode which the model refers to</span>
<span class="sd">			folder: str</span>
<span class="sd">				Folder in which everything is kept (if None, models must be loaded manually with load())</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span> <span class="c1">#(l,m) tuple</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">readme</span> <span class="o">=</span> <span class="kc">None</span>	

		<span class="k">if</span> <span class="n">folder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
		<span class="k">return</span>
	
	<span class="k">def</span> <span class="nf">get_raw_grads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;You cannot use base class to compute the WF gradients&quot;</span><span class="p">)</span>		
	
	<span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">folder</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;You cannot use base class to load a mode generator&quot;</span><span class="p">)</span>
	
	<span class="k">def</span> <span class="nf">get_raw_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;You cannot use base class to generate a mode&quot;</span><span class="p">)</span>		

	<span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
		<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No summary has been implemented for the current model&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="mode_generator_base.lm"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.mode_generator_base.lm">[docs]</a>	<span class="k">def</span> <span class="nf">lm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns the (l,m) index of the mode.</span>
<span class="sd">		</span>
<span class="sd">		Output:</span>
<span class="sd">			mode: tuple</span>
<span class="sd">				(l,m) tuple for the mode</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span></div>

<div class="viewcode-block" id="mode_generator_base.get_time_grid"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.mode_generator_base.get_time_grid">[docs]</a>	<span class="k">def</span> <span class="nf">get_time_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns the time grid at which the output of the models is evaluated. Grid is in reduced units (s/M_sun).</span>

<span class="sd">		Output:</span>
<span class="sd">			time_grid: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (D&#39;,) - points in time grid at which all waves are evaluated</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span></div>


<div class="viewcode-block" id="mode_generator_base.get_mode"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.mode_generator_base.get_mode">[docs]</a>	<span class="k">def</span> <span class="nf">get_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">t_grid</span><span class="p">,</span> <span class="n">out_type</span> <span class="o">=</span> <span class="s2">&quot;ampph&quot;</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Generates the mode according to the MLGW model.</span>
<span class="sd">		hlm(t; theta) = A(t) * exp(1j*phi(t)) </span>
<span class="sd">		The mode is time-shifted such that zero of time is where the 22 mode has a peak.</span>
<span class="sd">		It accepts data in one of the following layout of D features:</span>
<span class="sd">		</span>
<span class="sd">			D = 3	[q, spin1_z, spin2_z]</span>
<span class="sd">		</span>
<span class="sd">			D = 4	[m1, m2, spin1_z, spin2_z]</span>
<span class="sd">		</span>
<span class="sd">		Unit of measures:</span>
<span class="sd">		</span>
<span class="sd">			[mass] = M_sun</span>
<span class="sd">		</span>
<span class="sd">			[spin] = adimensional</span>
<span class="sd">		</span>
<span class="sd">		If D = 3, the mode is evalutated at the std total mass M = 20 M_sun</span>
<span class="sd">		Output waveforms are returned with amplitude and pahse (out_type = &quot;ampph&quot;) or with real and imaginary part (out_type = &quot;realimag&quot;).</span>

<span class="sd">		Input:</span>
<span class="sd">			theta: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (D,)/(N,D) - source parameters to make prediction at</span>
<span class="sd">			t_grid: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (D&#39;,) - grid in time to evaluate the wave at (uses np.interp)</span>
<span class="sd">			out_type: str</span>
<span class="sd">				the output to be returned (&#39;ampph&#39;, &#39;realimag&#39;)</span>

<span class="sd">		Ouput:</span>
<span class="sd">			amp, phase :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (1,D)/(N,D) - desidered amplitude and phase (if it applies)</span>
<span class="sd">			hlm_real, hlm_im :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (1,D)/(N,D) - desidered h_22 components (if it applies)</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">out_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;realimag&quot;</span><span class="p">,</span> <span class="s2">&quot;ampph&quot;</span><span class="p">]:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong output type chosen. Expected </span><span class="se">\&quot;</span><span class="s2">realimag</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">ampph</span><span class="se">\&quot;</span><span class="s2">, given </span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="o">+</span><span class="n">out_type</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>

		<span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="c1">#to ensure that theta is copied into new array</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t_grid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="c1">#making sure that t_grid is np.array</span>
			<span class="n">t_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t_grid</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">theta</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">to_reshape</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1">#whether return a one dimensional array</span>
			<span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span> <span class="c1">#(1,D)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">to_reshape</span> <span class="o">=</span> <span class="kc">False</span>
		
		<span class="n">D</span><span class="o">=</span> <span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#number of features given</span>
		<span class="k">if</span> <span class="n">D</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]:</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unable to generata mode. Wrong number of BBH parameters!!&quot;</span><span class="p">)</span>
			<span class="k">return</span>

			<span class="c1">#checking if grid is ok</span>
		<span class="k">if</span> <span class="n">t_grid</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unable to generata mode. Wrong shape (</span><span class="si">{}</span><span class="s2">) of time grid!!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
			<span class="k">return</span>

			<span class="c1">#generating waves and returning to user</span>
		<span class="n">res1</span><span class="p">,</span> <span class="n">res2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_mode</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">t_grid</span><span class="p">,</span> <span class="n">out_type</span><span class="p">)</span> <span class="c1">#(N,D)</span>
		<span class="k">if</span> <span class="n">to_reshape</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">res1</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">res2</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="c1">#(D,)</span>
		<span class="k">return</span> <span class="n">res1</span><span class="p">,</span> <span class="n">res2</span> <span class="c1">#(N,D)</span></div>

	<span class="c1">#@do_profile(follow=[])</span>
	<span class="k">def</span> <span class="nf">__get_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">t_grid</span><span class="p">,</span> <span class="n">out_type</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>

<span class="sd">		Generates the mode in domain and perform. Called by get_mode.</span>
<span class="sd">		Accepts only input features as [q,s1,s2] or [m1, m2, spin1_z , spin2_z, D_L, inclination, phi_0].</span>
<span class="sd">		</span>
<span class="sd">		Input:</span>
<span class="sd">			theta: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,D) - source parameters to make prediction at (D=3 or D=4)</span>
<span class="sd">			t_grid: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (D&#39;,) - a grid in time to evaluate the wave at (uses np.interp)</span>
<span class="sd">			out_type: str</span>
<span class="sd">				the output to be returned (&#39;ampph&#39;, &#39;realimag&#39;)</span>
<span class="sd">		Output:</span>
<span class="sd">			amp, phase: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,D&#39;) - desidered amplitude and phase (if it applies)</span>
<span class="sd">			hlm_real, hlm_im: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,D&#39;) - desidered h_22 components (if it applies)</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">D</span><span class="o">=</span> <span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#number of features given</span>
		<span class="k">assert</span> <span class="n">D</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="c1">#check that the number of dimension is fine</span>

			<span class="c1">#setting theta_std &amp; m_tot_us</span>
		<span class="k">if</span> <span class="n">D</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
			<span class="n">theta_std</span> <span class="o">=</span> <span class="n">theta</span>
			<span class="n">m_tot_us</span> <span class="o">=</span> <span class="mf">20.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))</span> 
		<span class="k">else</span><span class="p">:</span>
			<span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span> <span class="c1">#theta[:,0]/theta[:,1] #mass ratio (general) (N,)</span>
			<span class="n">m_tot_us</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">theta</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>	<span class="c1">#total mass in solar masses for the user</span>
			<span class="n">theta_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">q</span><span class="p">,</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]))</span> <span class="c1">#(N,3)</span>

			<span class="n">to_switch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">theta_std</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">1.</span><span class="p">)</span> <span class="c1">#holds the indices of the events to swap</span>

				<span class="c1">#switching masses (where relevant)</span>
			<span class="n">theta_std</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">theta_std</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">theta_std</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">theta_std</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta_std</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">theta_std</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

		<span class="n">amp</span><span class="p">,</span> <span class="n">ph</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">get_raw_mode</span><span class="p">(</span><span class="n">theta_std</span><span class="p">)</span> <span class="c1">#raw WF (N, N_grid)</span>

			<span class="c1">#doing interpolations</span>
			<span class="c1">############</span>
		<span class="n">new_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">amp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="n">new_ph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">amp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">amp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
				<span class="c1">#computing the true red grid</span>
			<span class="n">interp_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">t_grid</span><span class="p">,</span> <span class="n">m_tot_us</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="c1">#FIXME: here you can already apply spherical harmonics (calling _set_spherical_harmonics) for speed up</span>

				<span class="c1">#putting the wave on the user grid</span>
			<span class="n">new_amp</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">interp_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">amp</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">#set to zero outside the domain</span>
			<span class="n">new_ph</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">interp_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">ph</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>

				<span class="c1">#warning if the model extrapolates outiside the grid</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">interp_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
				<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Warning: time grid given is too long for the fitted model. Set 0 amplitude outside the fitting domain.&quot;</span><span class="p">)</span>

			<span class="c1">#amplitude and phase of the mode (maximum of amp at t=0)</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode_generator_NN</span><span class="p">):</span>
				<span class="c1">#FIXME: make this consistent and not super random as it is now</span>
			<span class="n">nu</span> <span class="o">=</span> <span class="n">theta_std</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">theta_std</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
			<span class="n">phi_diff</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">):</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">):</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">):</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">}</span>			
		<span class="k">else</span><span class="p">:</span>
			<span class="n">nu</span><span class="p">,</span> <span class="n">phi_diff</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
		<span class="n">amp</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_amp</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">nu</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
		<span class="n">ph</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_ph</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">new_ph</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">phi_diff</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">])</span><span class="o">.</span><span class="n">T</span> <span class="c1">#phase is zero at the beginning of the WF</span>

		<span class="k">if</span> <span class="n">out_type</span> <span class="o">==</span> <span class="s1">&#39;ampph&#39;</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">amp</span><span class="p">,</span> <span class="n">ph</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">hlm_real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">amp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ph</span><span class="p">))</span>
			<span class="n">hlm_imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">amp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ph</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">hlm_real</span><span class="p">,</span> <span class="n">hlm_imag</span>

<div class="viewcode-block" id="mode_generator_base.PCA_models"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.mode_generator_base.PCA_models">[docs]</a>	<span class="k">def</span> <span class="nf">PCA_models</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_type</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns the PCA model.</span>
<span class="sd">		</span>
<span class="sd">		Input:</span>
<span class="sd">			model_type:	str</span>
<span class="sd">				&quot;amp&quot; or &quot;ph&quot; to state which PCA model shall be returned</span>

<span class="sd">		Output:</span>
<span class="sd">			PCA_model: :class:`PCA_model`</span>
<span class="sd">				The required PCA model</span>
<span class="sd">			</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;amp&quot;</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_PCA</span>
		<span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;ph&quot;</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ph_PCA</span>
		<span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="mode_generator_base.get_grads"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.mode_generator_base.get_grads">[docs]</a>	<span class="k">def</span> <span class="nf">get_grads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">t_grid</span><span class="p">,</span> <span class="n">out_type</span> <span class="o">=</span><span class="s2">&quot;realimag&quot;</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns the gradient of the mode</span>

<span class="sd">		.. math::</span>

<span class="sd">			h_{lm} = A e^{i\phi} = A \cos(\phi) + i A sin(\phi)</span>

<span class="sd">		with respect to theta = (M, q, s1, s2).</span>
<span class="sd">		Gradients are evaluated on the user given time grid t_grid.</span>
<span class="sd">		It returns the real and imaginary part of the gradients.</span>
<span class="sd">		</span>
<span class="sd">		Input:</span>
<span class="sd">			theta: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,D) - orbital parameters with format (m1, m2, s1, s2)</span>
<span class="sd">			t_grid: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (D&#39;,) - time grid to evaluate the gradients at</span>
<span class="sd">			out_type: str</span>
<span class="sd">				whether to compute gradients of the real and imaginary part (&#39;realimag&#39;) or of amplitude and phase (&#39;ampph&#39;)</span>
<span class="sd">		</span>
<span class="sd">		Output:</span>
<span class="sd">			grad_Re(h): :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,D,4) - Gradients of the real part of the waveform</span>
<span class="sd">			grad_Im(h): :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,D,4) - Gradients of the imaginary part of the waveform</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">out_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;realimag&quot;</span><span class="p">,</span> <span class="s2">&quot;ampph&quot;</span><span class="p">]:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong output type chosen. Expected </span><span class="se">\&quot;</span><span class="s2">realimag</span><span class="se">\&quot;</span><span class="s2">, </span><span class="se">\&quot;</span><span class="s2">ampph</span><span class="se">\&quot;</span><span class="s2">, given </span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="o">+</span><span class="n">out_type</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
			<span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[:,:</span><span class="mi">4</span><span class="p">]</span>
		<span class="k">elif</span> <span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong input values for theta: expected shape (None,4) [m1,m2,s1,s2]&quot;</span><span class="p">)</span>

			<span class="c1">#creating theta_std</span>
		<span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span> <span class="c1">#theta[:,0]/theta[:,1] #mass ratio (general) (N,)</span>
		
		<span class="n">m_tot_us</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">theta</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>	<span class="c1">#total mass in solar masses for the user</span>
		<span class="n">theta_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">q</span><span class="p">,</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span><span class="n">theta</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]))</span> <span class="c1">#(N,3)</span>
			<span class="c1">#switching masses (where relevant)</span>
		<span class="n">to_switch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">theta_std</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">1.</span><span class="p">)</span> <span class="c1">#holds the indices of the events to swap</span>
		<span class="n">theta_std</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">theta_std</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">theta_std</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">theta_std</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">theta_std</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">theta_std</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

		<span class="n">grad_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">theta_std</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_grid</span><span class="p">),</span> <span class="mi">4</span><span class="p">))</span>
		<span class="n">grad_ph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">theta_std</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_grid</span><span class="p">),</span> <span class="mi">4</span><span class="p">))</span>

		<span class="c1">#dealing with gradients w.r.t. (q,s1,s2)</span>
		<span class="n">grad_q_amp</span><span class="p">,</span> <span class="n">grad_q_ph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_raw_grads</span><span class="p">(</span><span class="n">theta_std</span><span class="p">)</span> <span class="c1">#(N,D_std,3)</span>
			<span class="c1">#interpolating gradients on the user grid</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">theta_std</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
			<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">):</span>
				<span class="c1">#print(t_grid.shape,self.times.shape)</span>
				<span class="n">grad_amp</span><span class="p">[</span><span class="n">i</span><span class="p">,:,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">t_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">*</span> <span class="n">m_tot_us</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">grad_q_amp</span><span class="p">[</span><span class="n">i</span><span class="p">,:,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">#set to zero outside the domain #(D,)</span>
				<span class="n">grad_ph</span><span class="p">[</span><span class="n">i</span><span class="p">,:,</span><span class="n">j</span><span class="p">]</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">t_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">*</span> <span class="n">m_tot_us</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">grad_q_ph</span><span class="p">[</span><span class="n">i</span><span class="p">,:,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1">#(D,)</span>

		<span class="c1">#dealing with gradients w.r.t. M</span>
		<span class="n">amp</span><span class="p">,</span> <span class="n">ph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mode</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">t_grid</span><span class="p">,</span> <span class="n">out_type</span> <span class="o">=</span> <span class="s2">&quot;ampph&quot;</span><span class="p">)</span> <span class="c1">#true wave evaluated at t_grid #(N,D)</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">theta_std</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
			<span class="n">grad_M_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">amp</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">t_grid</span><span class="p">)</span> <span class="c1">#(D,)</span>
			<span class="n">grad_M_ph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">ph</span><span class="p">[</span><span class="n">i</span><span class="p">,:],</span> <span class="n">t_grid</span><span class="p">)</span> <span class="c1">#(D,)</span>
				<span class="c1">#don&#39;t know why but things work here...</span>
			<span class="n">grad_amp</span><span class="p">[</span><span class="n">i</span><span class="p">,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">t_grid</span><span class="o">/</span><span class="n">m_tot_us</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">grad_M_amp</span><span class="p">)</span> <span class="c1">#(D,)</span>
			<span class="n">grad_ph</span><span class="p">[</span><span class="n">i</span><span class="p">,:,</span><span class="mi">0</span><span class="p">]</span>  <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">t_grid</span><span class="o">/</span><span class="n">m_tot_us</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">grad_M_ph</span><span class="p">)</span> <span class="c1">#(D,)</span>

		<span class="n">grad_ph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">grad_ph</span><span class="p">,</span><span class="n">grad_ph</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="kc">None</span><span class="p">,:])</span> <span class="c1">#unclear... but apparently compulsory</span>
			<span class="c1">#check when grad is zero and keeping it</span>
		<span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ph</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ph</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))),</span> <span class="n">axis</span> <span class="o">=</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diff</span><span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">grad_ph</span><span class="p">[</span><span class="n">zero</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">zero</span><span class="p">[</span><span class="mi">1</span><span class="p">],:]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#takes care of the flat part after ringdown (gradient there shall be zero!!)</span>


		<span class="k">if</span> <span class="n">out_type</span> <span class="o">==</span> <span class="s2">&quot;ampph&quot;</span><span class="p">:</span>
			<span class="c1">#switching back spins</span>
			<span class="c1">#sure of it???</span>
			<span class="n">grad_amp</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">grad_amp</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">grad_amp</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,:,</span><span class="mi">3</span><span class="p">],</span> <span class="n">grad_amp</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,:,</span><span class="mi">2</span><span class="p">]</span>
			<span class="n">grad_ph</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">grad_ph</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">grad_ph</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,:,</span><span class="mi">3</span><span class="p">],</span> <span class="n">grad_ph</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,:,</span><span class="mi">2</span><span class="p">]</span>
			<span class="k">return</span> <span class="n">grad_amp</span><span class="p">,</span> <span class="n">grad_ph</span>
		<span class="k">if</span> <span class="n">out_type</span> <span class="o">==</span> <span class="s2">&quot;realimag&quot;</span><span class="p">:</span>
			<span class="c1">#computing gradients of the real and imaginary part</span>
			<span class="n">ph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">ph</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">ph</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
			<span class="n">grad_Re</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">grad_amp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ph</span><span class="p">)[:,:,</span><span class="kc">None</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">grad_ph</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ph</span><span class="p">)[:,:,</span><span class="kc">None</span><span class="p">]),</span> <span class="n">amp</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">])</span> <span class="c1">#(N,D,4)</span>
			<span class="n">grad_Im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">grad_amp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ph</span><span class="p">)[:,:,</span><span class="kc">None</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">grad_ph</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ph</span><span class="p">)[:,:,</span><span class="kc">None</span><span class="p">]),</span> <span class="n">amp</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">])</span><span class="c1">#(N,D,4)</span>

			<span class="n">grad_Re</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">grad_Re</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">grad_Re</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,:,</span><span class="mi">3</span><span class="p">],</span> <span class="n">grad_Re</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,:,</span><span class="mi">2</span><span class="p">]</span>
			<span class="n">grad_Im</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">grad_Im</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">grad_Im</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,:,</span><span class="mi">3</span><span class="p">],</span> <span class="n">grad_Im</span><span class="p">[</span><span class="n">to_switch</span><span class="p">,:,</span><span class="mi">2</span><span class="p">]</span>
			<span class="k">return</span> <span class="n">grad_Re</span><span class="p">,</span> <span class="n">grad_Im</span></div></div>

<div class="viewcode-block" id="mode_generator_NN"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.mode_generator_NN">[docs]</a><span class="k">class</span> <span class="nc">mode_generator_NN</span><span class="p">(</span><span class="n">mode_generator_base</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	This class holds all the parts of ML models and acts as single (l,m) mode generator. Model is composed by a PCA model to reduce dimensionality of a WF datasets and by several NN models to fit PCA in terms of source parameters. WFs are generated in time domain.</span>
<span class="sd">	Everything is hold in a PCA model (:class:`PCA_model` defined in ML_routines) and in an ensemble of NN models. All models are loaded from files in a folder given by user. The folder structure should strictly follow this convention:</span>

<span class="sd">		#WRITEME</span>

<span class="sd">	&quot;&quot;&quot;</span>

<div class="viewcode-block" id="mode_generator_NN.load"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.mode_generator_NN.load">[docs]</a>	<span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">folder</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Loads all relevant PCA models, features and NN models.</span>
<span class="sd">		</span>
<span class="sd">		Inputs:</span>
<span class="sd">			folder: str</span>
<span class="sd">				Folder in which everything is kept</span>
<span class="sd">			verbose: bool</span>
<span class="sd">				Whether to be verbose</span>
<span class="sd">			batch_size: int</span>
<span class="sd">				Batch size for inference. A large number may provide a speed up at the cost of a large memory usage</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">folder</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unable to load folder &quot;</span><span class="o">+</span><span class="n">folder</span><span class="o">+</span><span class="s2">&quot;: no such directory!&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="c1">#define a verboseprint if verbose is true</span>
			<span class="k">def</span> <span class="nf">verboseprint</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
				<span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">verboseprint</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">k</span><span class="p">:</span> <span class="kc">None</span> <span class="c1"># do-nothing function</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="n">folder</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">):</span>
			<span class="n">folder</span> <span class="o">=</span> <span class="n">folder</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span>
		<span class="c1">#loading PCA</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">amp_PCA</span> <span class="o">=</span> <span class="n">PCA_model</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">amp_PCA</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span><span class="n">folder</span><span class="o">+</span><span class="s2">&quot;amp/amp_PCA_model.dat&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">ph_PCA</span> <span class="o">=</span> <span class="n">PCA_model</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">ph_PCA</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span><span class="n">folder</span><span class="o">+</span><span class="s2">&quot;ph/ph_PCA_model.dat&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">folder</span><span class="o">+</span><span class="s2">&quot;times.dat&quot;</span><span class="p">)</span>
		
		<span class="n">amp_directories</span> <span class="o">=</span> <span class="p">[</span><span class="n">folder</span><span class="o">+</span><span class="s1">&#39;amp/&#39;</span><span class="o">+</span><span class="n">dir_name</span> <span class="k">for</span> <span class="n">dir_name</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">folder</span><span class="o">+</span><span class="s1">&#39;amp&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">folder</span><span class="o">+</span><span class="s1">&#39;amp/&#39;</span><span class="o">+</span><span class="n">dir_name</span><span class="p">)]</span>
		<span class="n">ph_directories</span> <span class="o">=</span> <span class="p">[</span><span class="n">folder</span><span class="o">+</span><span class="s1">&#39;ph/&#39;</span><span class="o">+</span><span class="n">dir_name</span> <span class="k">for</span> <span class="n">dir_name</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">folder</span><span class="o">+</span><span class="s1">&#39;ph&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">folder</span><span class="o">+</span><span class="s1">&#39;ph/&#39;</span><span class="o">+</span><span class="n">dir_name</span><span class="p">)]</span>
		
		<span class="c1">#new way of loading in models (make them tf.functions?)</span>
		<span class="n">using_ph</span><span class="p">,</span> <span class="n">using_amp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ph_models</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ph_models_res</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_models</span><span class="p">,</span> <span class="n">amp_modeled_comps</span><span class="p">,</span> <span class="n">ph_modeled_comps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ph_modeled_comps_res</span> <span class="o">=</span> <span class="n">load_models_from_directories</span><span class="p">(</span><span class="n">amp_directories</span><span class="p">,</span> <span class="n">ph_directories</span><span class="p">)</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">using_ph</span> <span class="ow">and</span> <span class="n">using_amp</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Please supply both amplitude and phase models!&quot;</span><span class="p">)</span>
		
		<span class="sd">&#39;&#39;&#39; #old way of loading in the models</span>
<span class="sd">		with open(folder+&#39;amp_features.txt&#39;, &#39;r&#39;) as file:</span>
<span class="sd">			self.amp_features = file.readline().split(&quot;, &quot;)</span>
<span class="sd">			#print(self.amp_features)</span>
<span class="sd">		with open(folder+&#39;ph_2_features.txt&#39;, &#39;r&#39;) as file:</span>
<span class="sd">			self.ph_2_features = file.readline().split(&quot;, &quot;)</span>
<span class="sd">		with open(folder+&#39;ph_3456_features.txt&#39;, &#39;r&#39;) as file:</span>
<span class="sd">			self.ph_3456_features = file.readline().split(&quot;, &quot;)</span>
<span class="sd">		with open(folder+&#39;ph_2res_features.txt&#39;, &#39;r&#39;) as file:</span>
<span class="sd">			self.ph_2res_features = file.readline().split(&quot;, &quot;)</span>

<span class="sd">			#Loading the models for the various components</span>
<span class="sd">		n_feat_amp = augment_features([1,1,1], self.amp_features).shape[1]</span>
<span class="sd">		n_feat_ph_2 = augment_features([1,1,1], self.ph_2_features).shape[1]</span>
<span class="sd">		n_feat_ph_3456 = augment_features([1,1,1], self.ph_3456_features).shape[1]</span>
<span class="sd">		n_feat_ph_2res = augment_features([1,1,1], self.ph_2res_features).shape[1]</span>
<span class="sd">		self.model_amp = tf.function(keras_models.load_model(folder+&#39;model_amp.h5&#39;, custom_objects=None, compile=False),</span>
<span class="sd">			input_signature=(tf.TensorSpec(shape=[None, n_feat_amp], dtype=tf.float64),))</span>
<span class="sd">		self.model_ph_2 = tf.function(keras_models.load_model(folder+&#39;model_ph_2.h5&#39;, custom_objects=None, compile=False),</span>
<span class="sd">			input_signature=(tf.TensorSpec(shape=[None, n_feat_ph_2], dtype=tf.float64),))</span>
<span class="sd">		self.model_ph_3456 = tf.function(keras_models.load_model(folder+&#39;model_ph_3456.h5&#39;, custom_objects=None, compile=False),</span>
<span class="sd">			input_signature=(tf.TensorSpec(shape=[None, n_feat_ph_3456], dtype=tf.float64),))</span>
<span class="sd">		self.model_ph_2res = tf.function(keras_models.load_model(folder+&#39;model_ph_2res.h5&#39;, custom_objects=None, compile=False),</span>
<span class="sd">			input_signature=(tf.TensorSpec(shape=[None, n_feat_ph_2res], dtype=tf.float64),))</span>
<span class="sd">		</span>
<span class="sd">		self.res_coefficients = np.genfromtxt(folder+&quot;res_coefficients.txt&quot;)</span>
<span class="sd">		verboseprint(&quot;mode generator loaded succesfully&quot;)</span>
<span class="sd">		&#39;&#39;&#39;</span></div>

	<span class="c1">#@do_profile(follow=[])</span>
<div class="viewcode-block" id="mode_generator_NN.get_raw_mode"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.mode_generator_NN.get_raw_mode">[docs]</a>	<span class="k">def</span> <span class="nf">get_raw_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Generates a mode according to the MLGW model with a parameters vector in MLGW model style (params=  [q,s1z,s2z]).</span>
<span class="sd">		They are generated at masses m1 = q * m2 and m2 = 20/(1+q), so that M_tot = 20.</span>
<span class="sd">		Grid is the standard one.</span>
<span class="sd">		</span>
<span class="sd">		Input:</span>
<span class="sd">			theta: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,3) - source parameters to make prediction at</span>

<span class="sd">		Ouput:</span>
<span class="sd">			amp,ph: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,D) - desidered amplitude and phase, evaluated on the internal default time grid</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span>
		<span class="k">if</span> <span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">:</span>
			<span class="n">coeff_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_red_coefficients</span><span class="p">(</span><span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">batch_size</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">)]</span>
			<span class="n">rec_PCA_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeff_list</span><span class="p">],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">rec_PCA_ph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeff_list</span><span class="p">],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">rec_PCA_amp</span><span class="p">,</span> <span class="n">rec_PCA_ph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_red_coefficients</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="c1">#(N,K)</span>

		<span class="n">rec_amp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_PCA</span><span class="o">.</span><span class="n">reconstruct_data</span><span class="p">(</span><span class="n">rec_PCA_amp</span><span class="p">)</span> <span class="c1">#(N,D)</span>
		<span class="n">rec_ph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ph_PCA</span><span class="o">.</span><span class="n">reconstruct_data</span><span class="p">(</span><span class="n">rec_PCA_ph</span><span class="p">)</span> <span class="c1">#(N,D)</span>

		<span class="k">return</span> <span class="n">rec_amp</span><span class="p">,</span> <span class="n">rec_ph</span></div>

	<span class="c1">#@do_profile(follow=[])</span>
<div class="viewcode-block" id="mode_generator_NN.get_red_coefficients"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.mode_generator_NN.get_red_coefficients">[docs]</a>	<span class="k">def</span> <span class="nf">get_red_coefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns the PCA reduced coefficients, as estimated by the neural network models.</span>

<span class="sd">		Input:</span>
<span class="sd">			theta: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,3) - source parameters to make prediction at</span>

<span class="sd">		Output:</span>
<span class="sd">			red_amp,red_ph: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,K) - PCA reduced amplitude and phase</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="c1">#new way</span>
		<span class="n">amp_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_PCA</span><span class="o">.</span><span class="n">get_dimensions</span><span class="p">()[</span><span class="mi">1</span><span class="p">]))</span>
		<span class="n">ph_pred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ph_PCA</span><span class="o">.</span><span class="n">get_dimensions</span><span class="p">()[</span><span class="mi">1</span><span class="p">]))</span>
		
		<span class="k">for</span> <span class="n">comps</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_models</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">amp_pred</span><span class="p">[:,</span><span class="nb">list</span><span class="p">(</span><span class="n">comps</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_models</span><span class="p">[</span><span class="n">comps</span><span class="p">]</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
		
		<span class="k">for</span> <span class="n">comps</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ph_models</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">ph_pred</span><span class="p">[:,</span><span class="nb">list</span><span class="p">(</span><span class="n">comps</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ph_models</span><span class="p">[</span><span class="n">comps</span><span class="p">]</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        
		<span class="k">for</span> <span class="n">comps</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ph_models_res</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
			<span class="n">cur_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ph_models_res</span><span class="p">[</span><span class="n">comps</span><span class="p">]</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">:</span>
				<span class="n">ph_pred</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cur_pred</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ph_modeled_comps_res</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
		
		<span class="sd">&#39;&#39;&#39;#old way</span>
<span class="sd">		amp_theta = augment_features(theta, self.amp_features)</span>
<span class="sd">		ph_2_theta = augment_features(theta, self.ph_2_features)</span>
<span class="sd">		ph_3456_theta = augment_features(theta, self.ph_3456_features)</span>
<span class="sd">		ph_2res_theta = augment_features(theta, self.ph_2res_features)</span>
<span class="sd">		</span>
<span class="sd">		amp_pred = np.zeros((amp_theta.shape[0], self.amp_PCA.get_dimensions()[1]))</span>
<span class="sd">		ph_pred = np.zeros((ph_2_theta.shape[0], self.ph_PCA.get_dimensions()[1]))</span>
<span class="sd">		</span>
<span class="sd">		#amp_pred[:,:4] = self.model_amp.predict(amp_theta, verbose=0)</span>
<span class="sd">		#ph_2_pred = self.model_ph_2.predict(ph_2_theta, verbose=0)</span>
<span class="sd">		#ph_3456_pred = self.model_ph_3456.predict(ph_3456_theta, verbose=0)</span>
<span class="sd">		#ph_2res_pred = self.model_ph_2res.predict(ph_2res_theta, verbose=0)</span>

<span class="sd">		amp_pred[:,:4] = self.model_amp(amp_theta).numpy()</span>
<span class="sd">		ph_2_pred = self.model_ph_2(ph_2_theta).numpy()</span>
<span class="sd">		ph_3456_pred = self.model_ph_3456(ph_3456_theta).numpy()</span>
<span class="sd">		ph_2res_pred = self.model_ph_2res(ph_2res_theta).numpy()</span>
<span class="sd">			</span>
<span class="sd">		ph_2res_pred[:,0]*=self.res_coefficients[0]</span>
<span class="sd">		ph_2res_pred[:,1]*=self.res_coefficients[1]</span>
<span class="sd">		</span>
<span class="sd">		ph_2_pred += ph_2res_pred</span>
<span class="sd">		ph_pred[:,:6] = np.concatenate((ph_2_pred,ph_3456_pred), axis=1)</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="n">amp_pred</span><span class="p">,</span> <span class="n">ph_pred</span></div></div>

<div class="viewcode-block" id="mode_generator_MoE"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.mode_generator_MoE">[docs]</a><span class="k">class</span> <span class="nc">mode_generator_MoE</span><span class="p">(</span><span class="n">mode_generator_base</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	This class holds all the parts of ML models and acts as single (l,m) mode generator. Model is composed by a PCA model to reduce dimensionality of a WF datasets and by several MoE models to fit PCA in terms of source parameters. WFs are generated in time domain.</span>
<span class="sd">	Everything is hold in a PCA model (class PCA_model defined in ML_routines) and in two lists of MoE models (class MoE_model defined in EM_MoE). All models are loaded from files in a folder given by user. Files must be named exactly as follows:</span>
<span class="sd">	</span>
<span class="sd">		amp(ph)_exp_#		for amplitude (phase) of expert model for PCA component #</span>
<span class="sd">	</span>
<span class="sd">		amp(ph)_gat_#		for amplitude (phase) of gating function for PCA component #</span>
<span class="sd">	</span>
<span class="sd">		amp(ph)_feat		for list of features to use for MoE models</span>
<span class="sd">	</span>
<span class="sd">		amp(ph)_PCA_model	for PCA model for amplitude (phase)</span>
<span class="sd">	</span>
<span class="sd">		times/frequencies	file holding grid points at which waves generated by PCA are evaluated</span>
<span class="sd">	</span>
<span class="sd">	No suffixes shall be given to files.</span>
<span class="sd">	The class doesn&#39;t implement methods for fitting: it only provides a useful tool to gather them.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">init_doc</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">	__init__</span>
<span class="s2">	========</span>
<span class="s2">		Initialise class by loading models from file.</span>
<span class="s2">		Everything useful for the model must be put within the folder with the standard names:</span>
<span class="s2">			{amp(ph)_exp_# ; amp(ph)_gat_#	; amp(ph)_feat ; amp(ph)_PCA_model; times/frequencies}</span>
<span class="s2">		There can be an arbitrary number of exp and gating functions as long as they match with each other and they are less than PCA components.</span>
<span class="s2">		A compulsory file times must hold a list of grid points at which the generated ML wave is evaluated.</span>
<span class="s2">		An optional README file holds more information about the model (in the format of a dictionary).</span>
<span class="s2">		Input:</span>
<span class="s2">			mode: tuple</span>
<span class="s2">				tuple (l,m) of the mode which the model refers to</span>
<span class="s2">			folder: str</span>
<span class="s2">				Folder in which everything is kept (if None, models must be loaded manually with load())</span>
<span class="s2">	&quot;&quot;&quot;</span>

<div class="viewcode-block" id="mode_generator_MoE.PCA_models"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.mode_generator_MoE.PCA_models">[docs]</a>	<span class="k">def</span> <span class="nf">PCA_models</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_type</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns the PCA model.</span>
<span class="sd">		</span>
<span class="sd">		Input:</span>
<span class="sd">			model_type:	str</span>
<span class="sd">				&quot;amp&quot; or &quot;ph&quot; to state which PCA model shall be returned</span>

<span class="sd">		Output:</span>
<span class="sd">			PCA_model: :class:`PCA_model`</span>
<span class="sd">				The required PCA model</span>
<span class="sd">			</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;amp&quot;</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_PCA</span>
		<span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;ph&quot;</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ph_PCA</span>
		<span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="mode_generator_MoE.get_raw_mode"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.mode_generator_MoE.get_raw_mode">[docs]</a>	<span class="k">def</span> <span class="nf">get_raw_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Generates a mode according to the MLGW model with a parameters vector in MLGW model style (params=  [q,s1z,s2z]).</span>
<span class="sd">		They are generated at masses m1 = q * m2 and m2 = 20/(1+q), so that M_tot = 20.</span>
<span class="sd">		Grid is the standard one.</span>
<span class="sd">		</span>
<span class="sd">		Input:</span>
<span class="sd">			theta: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,3) - source parameters to make prediction at</span>

<span class="sd">		Ouput:</span>
<span class="sd">			amp,ph: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,D) - desidered amplitude and phase, evaluated on the internal default time grid</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">rec_PCA_amp</span><span class="p">,</span> <span class="n">rec_PCA_ph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_red_coefficients</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="c1">#(N,K)</span>

		<span class="n">rec_amp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_PCA</span><span class="o">.</span><span class="n">reconstruct_data</span><span class="p">(</span><span class="n">rec_PCA_amp</span><span class="p">)</span> <span class="c1">#(N,D)</span>
		<span class="n">rec_ph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ph_PCA</span><span class="o">.</span><span class="n">reconstruct_data</span><span class="p">(</span><span class="n">rec_PCA_ph</span><span class="p">)</span> <span class="c1">#(N,D)</span>

		<span class="k">return</span> <span class="n">rec_amp</span><span class="p">,</span> <span class="n">rec_ph</span></div>

	<span class="k">def</span> <span class="nf">__read_features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feat_file</span><span class="p">):</span>	
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Extract the features of a MoE regression from a given file.</span>

<span class="sd">		Input:</span>
<span class="sd">			feat_file: str</span>
<span class="sd">				path to file</span>

<span class="sd">		Output:</span>
<span class="sd">			feat_list: list</span>
<span class="sd">				list of features</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">feat_file</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
		<span class="n">feat_list</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">feat_list</span><span class="p">)):</span>
			<span class="n">feat_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">feat_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
		<span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
		<span class="k">return</span> <span class="n">feat_list</span>

<div class="viewcode-block" id="mode_generator_MoE.load"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.mode_generator_MoE.load">[docs]</a>	<span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">folder</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Builds up all the models from given folder.</span>
<span class="sd">		Everything useful for the model must be put within the folder with the standard names:</span>

<span class="sd">			{amp(ph)_exp_# ; amp(ph)_gat_#	; amp(ph)_feat ; amp(ph)_PCA_model}</span>

<span class="sd">		There can be an arbitrary number of exp and gating functions as long as they match with each other and they are less than PCA components.</span>
<span class="sd">		It loads time vector.</span>
<span class="sd">		If given, it loads as a dictionary the README file. Dictionary should include entries (all optional): &#39;description&#39;, &#39;mode&#39;, &#39;train model&#39;, &#39;q range&#39;, &#39;s1 range&#39;, &#39;s2 range&#39;.</span>

<span class="sd">		Input:</span>
<span class="sd">			folder: str</span>
<span class="sd">				folder in which everything is kept</span>
<span class="sd">			verbose: bool</span>
<span class="sd">				whether to print output</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">folder</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unable to load folder &quot;</span><span class="o">+</span><span class="n">folder</span><span class="o">+</span><span class="s2">&quot;: no such directory!&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="c1">#define a verboseprint if verbose is true</span>
			<span class="k">def</span> <span class="nf">verboseprint</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
				<span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">verboseprint</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">k</span><span class="p">:</span> <span class="kc">None</span> <span class="c1"># do-nothing function</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="n">folder</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">):</span>
			<span class="n">folder</span> <span class="o">=</span> <span class="n">folder</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span>
		<span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;Loading model for &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; from: &quot;</span><span class="p">,</span> <span class="n">folder</span><span class="p">)</span>
		<span class="n">file_list</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span>

			<span class="c1">#loading PCA</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">amp_PCA</span> <span class="o">=</span> <span class="n">PCA_model</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">amp_PCA</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span><span class="n">folder</span><span class="o">+</span><span class="s2">&quot;amp_PCA_model&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">ph_PCA</span> <span class="o">=</span> <span class="n">PCA_model</span><span class="p">()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">ph_PCA</span><span class="o">.</span><span class="n">load_model</span><span class="p">(</span><span class="n">folder</span><span class="o">+</span><span class="s2">&quot;ph_PCA_model&quot;</span><span class="p">)</span>

		<span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;  Loaded PCA model for amplitude with &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_PCA</span><span class="o">.</span><span class="n">get_V_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot; PC&quot;</span><span class="p">)</span>
		<span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;  Loaded PCA model for phase with &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ph_PCA</span><span class="o">.</span><span class="n">get_V_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot; PC&quot;</span><span class="p">)</span>

			<span class="c1">#loading features</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">amp_features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__read_features</span><span class="p">(</span><span class="n">folder</span><span class="o">+</span><span class="s2">&quot;amp_feat&quot;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">ph_features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__read_features</span><span class="p">(</span><span class="n">folder</span><span class="o">+</span><span class="s2">&quot;ph_feat&quot;</span><span class="p">)</span>

		<span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;  Loaded features for amplitude: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_features</span><span class="p">)</span>
		<span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;  Loaded features for phase: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ph_features</span><span class="p">)</span>
	
			<span class="c1">#loading MoE models</span>
		<span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;  Loading MoE models&quot;</span><span class="p">)</span>
			<span class="c1">#amplitude</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">MoE_models_amp</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">while</span> <span class="s2">&quot;amp_exp_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="n">file_list</span> <span class="ow">and</span>  <span class="s2">&quot;amp_gat_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="n">file_list</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">MoE_models_amp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MoE_model</span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">amp_features</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">MoE_models_amp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">folder</span><span class="o">+</span><span class="s2">&quot;amp_exp_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">folder</span><span class="o">+</span><span class="s2">&quot;amp_gat_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
			<span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;    Loaded amplitude model for comp: &quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
			<span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
		
			<span class="c1">#phase</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">MoE_models_ph</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">while</span> <span class="s2">&quot;ph_exp_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="n">file_list</span> <span class="ow">and</span>  <span class="s2">&quot;ph_gat_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="n">file_list</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">MoE_models_ph</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MoE_model</span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ph_features</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">MoE_models_ph</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">folder</span><span class="o">+</span><span class="s2">&quot;ph_exp_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="n">folder</span><span class="o">+</span><span class="s2">&quot;ph_gat_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
			<span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;    Loaded phase model for comp: &quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
			<span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

		<span class="k">if</span> <span class="s2">&quot;times&quot;</span> <span class="ow">in</span> <span class="n">file_list</span><span class="p">:</span>
			<span class="n">verboseprint</span><span class="p">(</span><span class="s2">&quot;  Loaded time vector&quot;</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">folder</span><span class="o">+</span><span class="s2">&quot;times&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Unable to load model: no time vector given!&quot;</span><span class="p">)</span>

		<span class="k">if</span> <span class="s1">&#39;README&#39;</span> <span class="ow">in</span> <span class="n">file_list</span><span class="p">:</span>
			<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">folder</span><span class="o">+</span><span class="s2">&quot;README&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
				<span class="n">contents</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">readme</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span> <span class="c1">#dictionary holding some relevant information about the model loaded</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">readme</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span> <span class="c1">#dictionary holding some relevant information about the model loaded</span>
				<span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">readme</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span>
			<span class="k">except</span><span class="p">:</span>
				<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;README file is not a valid dictionary: entry ignored&quot;</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">readme</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">readme</span> <span class="o">=</span> <span class="kc">None</span>

		<span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span> <span class="c1">#this has something to do with a speed up of matmul. Once it is called once, matmul gets much faster!</span>
		<span class="k">return</span></div>

<div class="viewcode-block" id="mode_generator_MoE.MoE_models"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.mode_generator_MoE.MoE_models">[docs]</a>	<span class="k">def</span> <span class="nf">MoE_models</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_type</span><span class="p">,</span> <span class="n">k_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns the MoE model(s).</span>

<span class="sd">		Input:</span>
<span class="sd">			model_type: str</span>
<span class="sd">				&quot;amp&quot; or &quot;ph&quot; to state which MoE models shall be returned</span>
<span class="sd">			k_list: list</span>
<span class="sd">				index(indices) of the model to be returned (if None all models are returned)</span>

<span class="sd">		Output:</span>
<span class="sd">			models: list</span>
<span class="sd">				list of MoE models :class:`MoE_model` to be returned</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">k_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">k_list</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;amp&quot;</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">MoE_models_amp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s2">&quot;ph&quot;</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">MoE_models_ph</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
		<span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="mode_generator_MoE.summary"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.mode_generator_MoE.summary">[docs]</a>	<span class="k">def</span> <span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Prints to screen a summary of the model currently used.</span>
<span class="sd">		If filename is given, output is redirected to file.</span>

<span class="sd">		Input:</span>
<span class="sd">			filename: str</span>
<span class="sd">				if not None, redirects the output to file</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">amp_exp_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">get_iperparams</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">MoE_models_amp</span><span class="p">]</span>
		<span class="n">ph_exp_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">get_iperparams</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">MoE_models_ph</span><span class="p">]</span>

		<span class="n">output</span> <span class="o">=</span> <span class="s2">&quot;###### Summary for MLGW model ######</span><span class="se">\n</span><span class="s2">&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">readme</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">readme</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
			<span class="k">if</span> <span class="s2">&quot;description&quot;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
				<span class="n">output</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readme</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
				<span class="n">keys</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;description&#39;</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
				<span class="n">output</span> <span class="o">+=</span> <span class="s2">&quot;   &quot;</span><span class="o">+</span><span class="n">k</span><span class="o">+</span><span class="s2">&quot;: &quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">readme</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

		<span class="n">output</span> <span class="o">+=</span> <span class="s2">&quot;   Grid size: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">amp_PCA</span><span class="o">.</span><span class="n">get_PCA_params</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span><span class="s2">&quot; </span><span class="se">\n</span><span class="s2">&quot;</span>
		<span class="n">output</span> <span class="o">+=</span> <span class="s2">&quot;   Minimum time: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">+</span><span class="s2">&quot; s/M_sun</span><span class="se">\n</span><span class="s2">&quot;</span>
			<span class="c1">#amplitude summary</span>
		<span class="n">output</span> <span class="o">+=</span> <span class="s2">&quot;   ## Model for Amplitude </span><span class="se">\n</span><span class="s2">&quot;</span>
		<span class="n">output</span> <span class="o">+=</span> <span class="s2">&quot;      - #PCs:          &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">amp_PCA</span><span class="o">.</span><span class="n">get_PCA_params</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
		<span class="n">output</span> <span class="o">+=</span> <span class="s2">&quot;      - #Experts:      &quot;</span><span class="o">+</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">amp_exp_list</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
		<span class="n">output</span> <span class="o">+=</span> <span class="s2">&quot;      - #Features:     &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MoE_models_amp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_iperparams</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
		<span class="n">output</span> <span class="o">+=</span> <span class="s2">&quot;      - Features:      &quot;</span><span class="o">+</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">amp_features</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
			<span class="c1">#phase summary</span>
		<span class="n">output</span> <span class="o">+=</span> <span class="s2">&quot;   ## Model for Phase </span><span class="se">\n</span><span class="s2">&quot;</span>
		<span class="n">output</span> <span class="o">+=</span> <span class="s2">&quot;      - #PCs:          &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ph_PCA</span><span class="o">.</span><span class="n">get_PCA_params</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
		<span class="n">output</span> <span class="o">+=</span> <span class="s2">&quot;      - #Experts:      &quot;</span><span class="o">+</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ph_exp_list</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
		<span class="n">output</span> <span class="o">+=</span> <span class="s2">&quot;      - #Features:     &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MoE_models_ph</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_iperparams</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
		<span class="n">output</span> <span class="o">+=</span> <span class="s2">&quot;      - Features:      &quot;</span><span class="o">+</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ph_features</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
		<span class="n">output</span> <span class="o">+=</span> <span class="s2">&quot;####################################&quot;</span>
	
		<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
			<span class="n">text_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span>
			<span class="n">text_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
			<span class="n">text_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
			<span class="k">return</span>
		<span class="k">elif</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Filename must be a string! &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span><span class="o">+</span><span class="s2">&quot; given. Output is redirected to standard output.&quot;</span> <span class="p">)</span>
		<span class="nb">print</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
		<span class="k">return</span></div>

	<span class="c1">#@do_profile(follow=[])</span>
<div class="viewcode-block" id="mode_generator_MoE.get_red_coefficients"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.mode_generator_MoE.get_red_coefficients">[docs]</a>	<span class="k">def</span> <span class="nf">get_red_coefficients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns the PCA reduced coefficients, as estimated by the MoE models.</span>

<span class="sd">		Input:</span>
<span class="sd">			theta: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,3) - source parameters to make prediction at</span>

<span class="sd">		Output:</span>
<span class="sd">			red_amp,red_ph: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,K) - PCA reduced amplitude and phase</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">assert</span> <span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong number of features given: expected 3 but </span><span class="si">{}</span><span class="s2"> given&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1">#DEBUG</span>

			<span class="c1">#adding extra features</span>
		<span class="n">amp_theta</span> <span class="o">=</span> <span class="n">add_extra_features</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_features</span><span class="p">,</span> <span class="n">log_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">ph_theta</span> <span class="o">=</span> <span class="n">add_extra_features</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ph_features</span><span class="p">,</span> <span class="n">log_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>

			<span class="c1">#making predictions for amplitude</span>
		<span class="n">rec_PCA_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">amp_theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_PCA</span><span class="o">.</span><span class="n">get_dimensions</span><span class="p">()[</span><span class="mi">1</span><span class="p">]))</span>
		<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MoE_models_amp</span><span class="p">)):</span>
			<span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_PCA</span><span class="o">.</span><span class="n">get_dimensions</span><span class="p">()[</span><span class="mi">1</span><span class="p">]:</span> <span class="k">break</span>
			<span class="n">rec_PCA_amp</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MoE_models_amp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">amp_theta</span><span class="p">)</span>

			<span class="c1">#making predictions for phase</span>
		<span class="n">rec_PCA_ph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ph_theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ph_PCA</span><span class="o">.</span><span class="n">get_dimensions</span><span class="p">()[</span><span class="mi">1</span><span class="p">]))</span>
		<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MoE_models_ph</span><span class="p">)):</span>
			<span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ph_PCA</span><span class="o">.</span><span class="n">get_dimensions</span><span class="p">()[</span><span class="mi">1</span><span class="p">]:</span> <span class="k">break</span>
			<span class="n">rec_PCA_ph</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MoE_models_ph</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">ph_theta</span><span class="p">)</span>

		<span class="k">return</span> <span class="n">rec_PCA_amp</span><span class="p">,</span> <span class="n">rec_PCA_ph</span></div>

	<span class="k">def</span> <span class="nf">__MoE_gradients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">MoE_model</span><span class="p">,</span> <span class="n">feature_list</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Computes the gradient of a MoE model with basis function expansion at the given value of theta.</span>
<span class="sd">		Gradient is computed with the chain rule:</span>
<span class="sd">			D_i y= D_j y * D_j/D_i</span>
<span class="sd">		where D_j/D_i is the jacobian of the feature augmentation.</span>
<span class="sd">		</span>
<span class="sd">		Input:</span>
<span class="sd">			theta: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,3) - Values of orbital parameters to compute the gradient at</span>
<span class="sd">			MoE_model: :class:`MoE_model`</span>
<span class="sd">				A mixture of expert model to make the gradient of</span>
<span class="sd">			feature_list: list</span>
<span class="sd">				List of features used in data augmentation</span>
<span class="sd">		</span>
<span class="sd">		Output:</span>
<span class="sd">			gradients: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,3) - Gradients for the model</span>
<span class="sd">		&quot;&quot;&quot;</span>
			<span class="c1">#L = len(feature_list)</span>
		<span class="n">jac_transf</span> <span class="o">=</span> <span class="n">jac_extra_features</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">feature_list</span><span class="p">,</span> <span class="n">log_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1">#(N,3+L,3)</span>
		<span class="n">MoE_grads</span> <span class="o">=</span> <span class="n">MoE_model</span><span class="o">.</span><span class="n">get_gradient</span><span class="p">(</span><span class="n">add_extra_features</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">feature_list</span><span class="p">,</span> <span class="n">log_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="c1">#(N,3+L)</span>
		<span class="n">gradients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">jac_transf</span><span class="p">,</span> <span class="n">MoE_grads</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">])</span> <span class="c1">#(N,3+L,3)</span>
		<span class="n">gradients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gradients</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#(N,3)</span>
		<span class="k">return</span> <span class="n">gradients</span>

<div class="viewcode-block" id="mode_generator_MoE.get_raw_grads"><a class="viewcode-back" href="../../api_reference/GW_generator.html#mlgw.GW_generator.mode_generator_MoE.get_raw_grads">[docs]</a>	<span class="k">def</span> <span class="nf">get_raw_grads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Computes the gradients of the amplitude and phase w.r.t. (q,s1,s2).</span>
<span class="sd">		Gradients are functions dependent on time and are evaluated on the internal reduced grid (mode_generator.get_time_grid()).</span>

<span class="sd">		Input:</span>
<span class="sd">			theta: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,3) - Values of orbital parameters to compute the gradient at</span>
<span class="sd">		</span>
<span class="sd">		Output:</span>
<span class="sd">			grad_amp: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,D,3) - Gradients of the amplitude</span>
<span class="sd">			grad_ph: :class:`~numpy:numpy.ndarray`</span>
<span class="sd">				shape (N,D,3) - Gradients of the phase</span>
<span class="sd">		&quot;&quot;&quot;</span>
			<span class="c1">#computing gradient for the reduced coefficients g</span>
		<span class="c1">#amp</span>
		<span class="n">D</span><span class="p">,</span> <span class="n">K_amp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_PCA</span><span class="o">.</span><span class="n">get_dimensions</span><span class="p">()</span>
		<span class="n">grad_g_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">K_amp</span><span class="p">,</span> <span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1">#(N,K,3)</span>
		<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K_amp</span><span class="p">):</span>
			<span class="n">grad_g_amp</span><span class="p">[:,</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__MoE_gradients</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">MoE_models_amp</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_features</span><span class="p">)</span> <span class="c1">#(N,3)</span>
		<span class="c1">#ph</span>
		<span class="n">D</span><span class="p">,</span> <span class="n">K_ph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ph_PCA</span><span class="o">.</span><span class="n">get_dimensions</span><span class="p">()</span>
		<span class="n">grad_g_ph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">K_ph</span><span class="p">,</span> <span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1">#(N,K,3)</span>
		<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K_ph</span><span class="p">):</span>
			<span class="n">grad_g_ph</span><span class="p">[:,</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__MoE_gradients</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">MoE_models_ph</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ph_features</span><span class="p">)</span> <span class="c1">#(N,3)</span>
		
			<span class="c1">#computing gradients</span>
		<span class="c1">#amp</span>
		<span class="n">grad_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">D</span><span class="p">,</span> <span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1">#(N,D,3)</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
			<span class="n">grad_amp</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_PCA</span><span class="o">.</span><span class="n">reconstruct_data</span><span class="p">(</span><span class="n">grad_g_amp</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_PCA</span><span class="o">.</span><span class="n">PCA_params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#(N,D)</span>
		<span class="c1">#ph</span>
		<span class="n">grad_ph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">D</span><span class="p">,</span> <span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1">#(N,D,3)</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
			<span class="n">grad_ph</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ph_PCA</span><span class="o">.</span><span class="n">reconstruct_data</span><span class="p">(</span><span class="n">grad_g_ph</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ph_PCA</span><span class="o">.</span><span class="n">PCA_params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#(N,D)</span>

		<span class="k">return</span> <span class="n">grad_amp</span><span class="p">,</span> <span class="n">grad_ph</span></div></div>

<span class="c1">#################</span>

</pre></div>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Stefano Schmidt
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2023, Stefano Schmidt.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>